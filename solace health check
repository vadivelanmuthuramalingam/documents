public class MinuteStats {

    private final AtomicInteger success = new AtomicInteger(0);
    private final AtomicInteger failure = new AtomicInteger(0);

    public void recordSuccess() {
        success.incrementAndGet();
    }

    public void recordFailure() {
        failure.incrementAndGet();
    }

    public int getSuccess() {
        return success.get();
    }

    public int getFailure() {
        return failure.get();
    }

    public int getTotal() {
        return success.get() + failure.get();
    }
}



üß† 2. DownstreamStatsTracker (Auto Cleanup Included)

@Component
public class DownstreamStatsTracker {

    /**
     * Key  : minute (epochMinute)
     * Value: success/failure stats for that minute
     */
    private final ConcurrentHashMap<Long, MinuteStats> minuteStatsMap =
            new ConcurrentHashMap<>();

    /** Keep only last N minutes */
    private static final int RETENTION_MINUTES = 2;

    private long currentMinute() {
        return System.currentTimeMillis() / 60000;
    }

    public void recordSuccess() {
        minuteStatsMap
                .computeIfAbsent(currentMinute(), k -> new MinuteStats())
                .recordSuccess();
    }

    public void recordFailure() {
        minuteStatsMap
                .computeIfAbsent(currentMinute(), k -> new MinuteStats())
                .recordFailure();
    }

    public MinuteStats getStatsForMinute(long minute) {
        return minuteStatsMap.get(minute);
    }

    /**
     * Automatically clears old minute records
     */
    public void cleanupOldMinutes() {
        long cutoffMinute = currentMinute() - RETENTION_MINUTES;

        minuteStatsMap.keySet().removeIf(minute -> minute < cutoffMinute);
    }
}

‚è±Ô∏è 3. Scheduled Health Evaluator (Every Minute)
@Component
@EnableScheduling
public class DownstreamHealthEvaluator {

    private final DownstreamStatsTracker tracker;

    private static final double FAILURE_THRESHOLD_PERCENT = 50.0;

    public DownstreamHealthEvaluator(DownstreamStatsTracker tracker) {
        this.tracker = tracker;
    }

    @Scheduled(fixedRate = 60000)
    public void evaluateLastMinute() {

        long lastMinute = (System.currentTimeMillis() / 60000) - 1;
        MinuteStats stats = tracker.getStatsForMinute(lastMinute);

        // Clean old data every cycle
        tracker.cleanupOldMinutes();

        if (stats == null || stats.getTotal() == 0) {
            return;
        }

        double failureRate =
                (stats.getFailure() * 100.0) / stats.getTotal();

        if (failureRate > FAILURE_THRESHOLD_PERCENT) {

            // ‚ùå Option A: Hard exit (not recommended for prod)
            // System.exit(1);

            // ‚úÖ Option B: Mark health DOWN (recommended)
            DownstreamHealthState.markUnhealthy();
        }
    }
}

‚ù§Ô∏è 4. Health State Holder (Shared Flag)
@Component
public class DownstreamHealthState {

    private static final AtomicBoolean unhealthy = new AtomicBoolean(false);

    public static void markUnhealthy() {
        unhealthy.set(true);
    }

    public static boolean isUnhealthy() {
        return unhealthy.get();
    }
}




@Component
public class DownstreamHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        if (DownstreamHealthState.isUnhealthy()) {
            return Health.down()
                    .withDetail("reason", "High downstream failure rate")
                    .build();
        }
        return Health.up().build();
    }
}


üß± 1. Capture the Tomcat Connector
@Component
public class TomcatConnectorHolder
        implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {

    private Connector connector;

    @Override
    public void customize(TomcatServletWebServerFactory factory) {
        factory.addConnectorCustomizers(connector -> this.connector = connector);
    }

    public void pause() {
        if (connector != null) {
            connector.pause();
        }
    }

    public void resume() {
        if (connector != null) {
            connector.resume();
        }
    }
}

üõë 2. Trigger Graceful Shutdown Manually
@Component
public class GracefulShutdownManager {

    private final TomcatConnectorHolder connectorHolder;
    private final InFlightTracker tracker;

    public GracefulShutdownManager(
            TomcatConnectorHolder connectorHolder,
            InFlightTracker tracker) {
        this.connectorHolder = connectorHolder;
        this.tracker = tracker;
    }

    public void shutdown() {

        // 1Ô∏è‚É£ Stop accepting new connections
        connectorHolder.pause();

        // 2Ô∏è‚É£ Wait for in-flight requests
        long timeoutMs = 30000;
        long start = System.currentTimeMillis();

        while (tracker.count() > 0 &&
               System.currentTimeMillis() - start < timeoutMs) {
            try { Thread.sleep(500); } catch (InterruptedException ignored) {}
        }

        // 3Ô∏è‚É£ Exit JVM
        System.exit(1);
    }
}

üßµ 3. Track In-Flight Requests (Mandatory)
@Component
public class InFlightTracker {
    private final AtomicInteger active = new AtomicInteger(0);
    public void start() { active.incrementAndGet(); }
    public void end() { active.decrementAndGet(); }
    public int count() { return active.get(); }
}


@Component
public class InFlightFilter implements Filter {

    private final InFlightTracker tracker;

    public InFlightFilter(InFlightTracker tracker) {
        this.tracker = tracker;
    }

    @Override
    public void doFilter(
        ServletRequest req, ServletResponse res, FilterChain chain)
        throws IOException, ServletException {

        tracker.start();
        try {
            chain.doFilter(req, res);
        } finally {
            tracker.end();
        }
    }
}


üü° Alternative 1: Close Spring ApplicationContext
ConfigurableApplicationContext context;

context.close();













