Clear Console --> printf "\033c"  or clear

ps --version
ps -eo %cpu
ps aux --sort=-%cpu
ps aux | sort -rk3,3
ps -eo pid,ppid,user,%mem,%cpu,cmd --sort=-%cpu

-------------------------------
nproc - CPU limit per server, which is not usefull for kubernetees, use the below command for openshft/kubernetees

cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us Example: 40000
cat /sys/fs/cgroup/cpu/cpu.cfs_period_us  Example: 100000
CPU limit = cpu.cfs_quota_us / cpu.cfs_period_us


CPU limit = 40000/100000 = .4 CPU or 400 millicores
Your pod is allowed to use 0.4 CPU cores, or 400 millicores.


====================================================================


Check Used CPU %
ps -eo %cpu | awk '{s+=$1} END {print s}'   	Example: 0.8

visible CPUs = nproc cmd value = example 22 (particular server CPU)

used CPU cores = (ps CPU%) √ó (visible CPUs / 100)
               = 0.8 √ó (22 / 100) = 0.176 cores

But your pod is only allowed 0.4 cores.

So to calculate used CPU % relative to quota:	
used CPU % = (used cores / allocated cores) √ó 100
           = (0.176 / 0.4) √ó 100 = 44%



import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import com.sun.management.OperatingSystemMXBean;

public class CpuUsageInspector {

    public static void main(String[] args) throws Exception {
        double quota = readCgroupValue("/sys/fs/cgroup/cpu/cpu.cfs_quota_us");
        double period = readCgroupValue("/sys/fs/cgroup/cpu/cpu.cfs_period_us");

        int availableProcessors = Runtime.getRuntime().availableProcessors();

        double cpuLimit = (quota > 0 && period > 0) ? (quota / period) : availableProcessors;

        // JVM CPU usage (over all cores) ‚Äî e.g., 0.2 means 20% of 1 core
        OperatingSystemMXBean osBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
        double processCpuLoad = osBean.getProcessCpuLoad(); // Between 0.0 and 1.0
        double usedCores = processCpuLoad * availableProcessors;
        double usedPercentOfLimit = (cpuLimit > 0) ? (usedCores / cpuLimit * 100) : 0;

        System.out.println("üß† Visible CPUs: " + availableProcessors);
        System.out.println("‚öôÔ∏è  CPU Limit (quota / period): " + cpuLimit + " cores");
        System.out.printf("üî• JVM CPU Usage: %.2f cores%n", usedCores);
        System.out.printf("üìä Usage vs Limit: %.2f%%%n", usedPercentOfLimit);
    }

    private static long readCgroupValue(String path) {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            return Long.parseLong(reader.readLine().trim());
        } catch (IOException | NumberFormatException e) {
            return -1;
        }
    }
}





Identify the JVM Processes Inside the Pod
=========================================================

ps -e -o pid,cmd | grep java


CPU Usage (Per Java Process)
========================================
top -p <pid> -b -n 1
	or
ps -p <pid> -o %cpu,cmd


Heap Usage (Per JVM)
=================================================
jcmd <pid> GC.heap_info

Example Output:
Heap
 def new generation   total 2097152K, used 1048576K [0x00000000f0000000, 0x0000000100000000, 0x0000000100000000)
  eden space 1835008K, 50% used [0x00000000f0000000, 0x00000000f8000000, 0x00000000fbc00000)
  from space 262144K, 0% used [0x00000000fbc00000, 0x00000000fbc00000, 0x00000000fc000000)
  to   space 262144K, 0% used [0x00000000fc000000, 0x00000000fc000000, 0x0000000100000000)
 tenured generation   total 4194304K, used 2097152K [0x0000000100000000, 0x0000000140000000)
   the space 4194304K, 50% used [0x0000000100000000, 0x0000000120000000, 0x0000000140000000)
 Metaspace       used 262144K, capacity 524288K, committed 393216K, reserved 1048576K
 class space    used 65536K, capacity 131072K, committed 98304K, reserved 262144K
 
 
jcmd <pid> GC.class_stats
jcmd <pid> GC.heap_info

jcmd <pid> VM.uptime
8978912321 s


jstat -gc <pid> 1000
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC       MU       CCSC     CCSU       YGC     YGCT     FGC     FGCT     GCT
1024.0 1024.0  512.0   0.0   8192.0   4096.0   16384.0    8192.0   2048.0   1024.0     256.0    128.0        15    0.150    3     0.220   0.370


Column		Description
S0C			Survivor 0 capacity (KB)
S1C			Survivor 1 capacity (KB)
S0U			Survivor 0 used (KB)
S1U			Survivor 1 used (KB)
EC			Eden space capacity (KB)
EU			Eden space used (KB)
OC			Old generation capacity (KB)
OU			Old generation used (KB)
MC			Metaspace capacity (KB)
MU			Metaspace used (KB)
CCSC		Compressed Class Space capacity (KB)
CCSU		Compressed Class Space used (KB)
YGC			Number of Young GCs since JVM start
YGCT		Total Young GC time (seconds)
FGC			Number of Full GCs
FGCT		Total Full GC time (seconds)
GCT			Total GC time (YGCT + FGCT)

 
Heap¬†Size=Total¬†Memory¬†Limit‚àí(Thread¬†Count√óStack¬†Size¬†per¬†Thread+Metaspace+JVM¬†overhead)
1024 - (100*1+128+128) 

What to focus on?
	New Generation (def new generation / Eden + Survivor spaces): Where short-lived objects are allocated
	Tenured Generation (tenured generation / the space): Where long-lived objects reside
	Metaspace / Class Space: JVM internal structures, growing as classes load/unload

1. Eden Space
	Purpose: Where new objects are initially allocated.
	It‚Äôs the primary allocation area in the young generation.
	Most objects start their life here.
	When Eden fills up, a minor garbage collection (GC) is triggered.

2. From Space (Survivor Space)
	One of two Survivor spaces in the Young Generation.
	During a minor GC, live objects in Eden and From Space are copied here (or promoted to Old Gen if old enough).
	It acts as a holding area for surviving objects after GC.
	At any time, one survivor space is called From Space (the source of surviving objects), the other is To Space.

3. To Space (Survivor Space)
	The other survivor space.
	Used as the destination during a minor GC.
	Surviving objects from Eden and From are copied here.
	After GC completes, roles of From and To spaces are switched.

How Do They Work Together?
	Objects are allocated in Eden.
	When Eden fills up ‚Üí Minor GC happens:
	Live objects in Eden and From Space are copied to To Space.
	Objects that survive enough minor GCs get promoted to Old Generation.

After GC:
	To Space becomes the new From Space.
	The old From Space becomes the new To Space (empty).







Stack Usage (Per JVM)
========================================================
How to Check the Default Thread Stack Size?
	java -XX:+PrintFlagsFinal -version | grep ThreadStackSize

Step 1: Get thread count-->          jcmd <pid> Thread.print | grep -c "nid="
									 jcmd <pid> Thread.print   -------- Equivelant to Thread Dump
Step 2: Get stack size--> 			 jcmd <pid> VM.flags | grep Xss
Step 3: Calculate total stack usage:-->     stack_usage = thread_count √ó Xss



State			Description
NEW				Thread has been created but not started yet.
RUNNABLE		Thread is executing or ready to execute, but may be waiting for CPU time.
BLOCKED			Thread is waiting to acquire a monitor lock to enter a synchronized block/method.
WAITING			Thread is waiting indefinitely for another thread to perform an action (e.g. join(), park()).
TIMED_WAITING	Thread is waiting for a specified period of time (e.g. sleep(), wait(timeout), join(timeout)).



"thread-name" #id daemon prio=5 os_prio=0 cpu=1234ms elapsed=5678ms tid=0x... nid=0x... waiting on condition [0x123217327432]


1. daemon
	Indicates whether the thread is a daemon thread or not.
	Daemon threads are background threads that do not prevent the JVM from exiting.
	If all non-daemon threads finish, the JVM shuts down even if daemon threads are still running.

	Example: Garbage collector threads, timer threads are often daemon threads.

2. prio=
	The Java thread priority (an integer from 1 to 10).
	Default is usually 5.
	Influences thread scheduling priority within the JVM (not strictly guaranteed by OS).
	Higher value means higher priority for CPU scheduling by the JVM.

3. os_prio=
	The operating system thread priority assigned to the thread.
	Reflects the priority level the OS uses to schedule the thread.
	Mapping between Java priority and OS priority depends on the JVM and OS.
	Can vary widely by platform.

4. cpu=
	The total CPU time consumed by the thread so far (usually in milliseconds).
	Shows how much CPU time the thread has used since it started.
	Useful for identifying threads that consume a lot of CPU.
	Note: Not all JVM implementations provide this info, but HotSpot typically does.

5. elapsed=
	The elapsed wall-clock time since the thread was started (usually in milliseconds).
	How long this thread has existed.
	Helps compare CPU time with total runtime to identify CPU-intensive threads.








public long getContainerCpuUsageNano() throws IOException {
    Path path = Paths.get("/sys/fs/cgroup/cpu/cpuacct.usage");
    return Long.parseLong(Files.readString(path).trim());
}

public double calculateCpuUsagePercentNano() throws IOException, InterruptedException {
    long startUsage = getContainerCpuUsageNano();
    long startTime = System.nanoTime();

    Thread.sleep(200); // short measurement window

    long endUsage = getContainerCpuUsageNano();
    long endTime = System.nanoTime();

    long cpuDelta = endUsage - startUsage;     // in nanoseconds
    long timeDelta = endTime - startTime;      // in nanoseconds
    int cpuCores = Runtime.getRuntime().availableProcessors();

    return (cpuDelta * 100.0) / (timeDelta * cpuCores);
}




public long getContainerCpuUsageNano() throws IOException {
    // For cgroups v1 (older systems)
    Path path = Paths.get("/sys/fs/cgroup/cpu/cpuacct.usage");
    return Long.parseLong(Files.readString(path).trim());
}


public long getContainerCpuUsageMicro() throws IOException {
    Path path = Paths.get("/sys/fs/cgroup/cpu.stat");
    List<String> lines = Files.readAllLines(path);
    for (String line : lines) {
        if (line.startsWith("usage_usec")) {
            return Long.parseLong(line.split(" ")[1].trim());
        }
    }
    throw new IOException("usage_usec not found");
}


int cpuCores = Runtime.getRuntime().availableProcessors();



public double calculateCpuUsagePercent() throws IOException, InterruptedException {
    long startUsage = getContainerCpuUsageNano();
    long startTime = System.nanoTime();

    Thread.sleep(2000); // wait 2 seconds

    long endUsage = getContainerCpuUsageNano();
    long endTime = System.nanoTime();

    long cpuDelta = endUsage - startUsage; // in nanoseconds
    long timeDelta = endTime - startTime;  // in nanoseconds

    int cpuCores = Runtime.getRuntime().availableProcessors();

    // CPU usage as a percentage of container's available CPUs
    double cpuUsagePercent = (cpuDelta * 100.0) / (timeDelta * cpuCores);

    return cpuUsagePercent;
}
