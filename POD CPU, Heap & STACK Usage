Clear Console --> printf "\033c"  or clear

ps --version
ps -eo %cpu
ps aux --sort=-%cpu
ps aux | sort -rk3,3
ps -eo pid,ppid,user,%mem,%cpu,cmd --sort=-%cpu

-------------------------------
nproc - CPU limit per server, which is not usefull for kubernetees, use the below command for openshft/kubernetees

cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us Example: 40000
cat /sys/fs/cgroup/cpu/cpu.cfs_period_us  Example: 100000
CPU limit = cpu.cfs_quota_us / cpu.cfs_period_us


CPU limit = 40000/100000 = .4 CPU or 400 millicores
Your pod is allowed to use 0.4 CPU cores, or 400 millicores.


====================================================================


Check Used CPU %
ps -eo %cpu | awk '{s+=$1} END {print s}'   	Example: 0.8

visible CPUs = nproc cmd value = example 22 (particular server CPU)

used CPU cores = (ps CPU%) √ó (visible CPUs / 100)
               = 0.8 √ó (22 / 100) = 0.176 cores

But your pod is only allowed 0.4 cores.

So to calculate used CPU % relative to quota:	
used CPU % = (used cores / allocated cores) √ó 100
           = (0.176 / 0.4) √ó 100 = 44%



import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import com.sun.management.OperatingSystemMXBean;

public class CpuUsageInspector {

    public static void main(String[] args) throws Exception {
        double quota = readCgroupValue("/sys/fs/cgroup/cpu/cpu.cfs_quota_us");
        double period = readCgroupValue("/sys/fs/cgroup/cpu/cpu.cfs_period_us");

        int availableProcessors = Runtime.getRuntime().availableProcessors();

        double cpuLimit = (quota > 0 && period > 0) ? (quota / period) : availableProcessors;

        // JVM CPU usage (over all cores) ‚Äî e.g., 0.2 means 20% of 1 core
        OperatingSystemMXBean osBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
        double processCpuLoad = osBean.getProcessCpuLoad(); // Between 0.0 and 1.0
        double usedCores = processCpuLoad * availableProcessors;
        double usedPercentOfLimit = (cpuLimit > 0) ? (usedCores / cpuLimit * 100) : 0;

        System.out.println("üß† Visible CPUs: " + availableProcessors);
        System.out.println("‚öôÔ∏è  CPU Limit (quota / period): " + cpuLimit + " cores");
        System.out.printf("üî• JVM CPU Usage: %.2f cores%n", usedCores);
        System.out.printf("üìä Usage vs Limit: %.2f%%%n", usedPercentOfLimit);
    }

    private static long readCgroupValue(String path) {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            return Long.parseLong(reader.readLine().trim());
        } catch (IOException | NumberFormatException e) {
            return -1;
        }
    }
}





Identify the JVM Processes Inside the Pod
=========================================================

ps -e -o pid,cmd | grep java


CPU Usage (Per Java Process)
========================================
top -p <pid> -b -n 1
	or
ps -p <pid> -o %cpu,cmd


Heap Usage (Per JVM)
=================================================
jcmd <pid> GC.heap_info

Example Output:
Heap
 def new generation   total 2097152K, used 1048576K [0x00000000f0000000, 0x0000000100000000, 0x0000000100000000)
  eden space 1835008K, 50% used [0x00000000f0000000, 0x00000000f8000000, 0x00000000fbc00000)
  from space 262144K, 0% used [0x00000000fbc00000, 0x00000000fbc00000, 0x00000000fc000000)
  to   space 262144K, 0% used [0x00000000fc000000, 0x00000000fc000000, 0x0000000100000000)
 tenured generation   total 4194304K, used 2097152K [0x0000000100000000, 0x0000000140000000)
   the space 4194304K, 50% used [0x0000000100000000, 0x0000000120000000, 0x0000000140000000)
 Metaspace       used 262144K, capacity 524288K, committed 393216K, reserved 1048576K
 class space    used 65536K, capacity 131072K, committed 98304K, reserved 262144K

What to focus on?
	New Generation (def new generation / Eden + Survivor spaces): Where short-lived objects are allocated
	Tenured Generation (tenured generation / the space): Where long-lived objects reside
	Metaspace / Class Space: JVM internal structures, growing as classes load/unload

1. Eden Space
	Purpose: Where new objects are initially allocated.
	It‚Äôs the primary allocation area in the young generation.
	Most objects start their life here.
	When Eden fills up, a minor garbage collection (GC) is triggered.

2. From Space (Survivor Space)
	One of two Survivor spaces in the Young Generation.
	During a minor GC, live objects in Eden and From Space are copied here (or promoted to Old Gen if old enough).
	It acts as a holding area for surviving objects after GC.
	At any time, one survivor space is called From Space (the source of surviving objects), the other is To Space.

3. To Space (Survivor Space)
	The other survivor space.
	Used as the destination during a minor GC.
	Surviving objects from Eden and From are copied here.
	After GC completes, roles of From and To spaces are switched.

How Do They Work Together?
	Objects are allocated in Eden.
	When Eden fills up ‚Üí Minor GC happens:
	Live objects in Eden and From Space are copied to To Space.
	Objects that survive enough minor GCs get promoted to Old Generation.

After GC:
	To Space becomes the new From Space.
	The old From Space becomes the new To Space (empty).







Stack Usage (Per JVM)
========================================================
How to Check the Default Thread Stack Size?
	java -XX:+PrintFlagsFinal -version | grep ThreadStackSize

Step 1: Get thread count-->          jcmd <pid> Thread.print | grep -c "nid="
Step 2: Get stack size--> 			 jcmd <pid> VM.flags | grep Xss
Step 3: Calculate total stack usage:-->     stack_usage = thread_count √ó Xss










public long getContainerCpuUsageNano() throws IOException {
    Path path = Paths.get("/sys/fs/cgroup/cpu/cpuacct.usage");
    return Long.parseLong(Files.readString(path).trim());
}

public double calculateCpuUsagePercentNano() throws IOException, InterruptedException {
    long startUsage = getContainerCpuUsageNano();
    long startTime = System.nanoTime();

    Thread.sleep(200); // short measurement window

    long endUsage = getContainerCpuUsageNano();
    long endTime = System.nanoTime();

    long cpuDelta = endUsage - startUsage;     // in nanoseconds
    long timeDelta = endTime - startTime;      // in nanoseconds
    int cpuCores = Runtime.getRuntime().availableProcessors();

    return (cpuDelta * 100.0) / (timeDelta * cpuCores);
}




public long getContainerCpuUsageNano() throws IOException {
    // For cgroups v1 (older systems)
    Path path = Paths.get("/sys/fs/cgroup/cpu/cpuacct.usage");
    return Long.parseLong(Files.readString(path).trim());
}


public long getContainerCpuUsageMicro() throws IOException {
    Path path = Paths.get("/sys/fs/cgroup/cpu.stat");
    List<String> lines = Files.readAllLines(path);
    for (String line : lines) {
        if (line.startsWith("usage_usec")) {
            return Long.parseLong(line.split(" ")[1].trim());
        }
    }
    throw new IOException("usage_usec not found");
}


int cpuCores = Runtime.getRuntime().availableProcessors();



public double calculateCpuUsagePercent() throws IOException, InterruptedException {
    long startUsage = getContainerCpuUsageNano();
    long startTime = System.nanoTime();

    Thread.sleep(2000); // wait 2 seconds

    long endUsage = getContainerCpuUsageNano();
    long endTime = System.nanoTime();

    long cpuDelta = endUsage - startUsage; // in nanoseconds
    long timeDelta = endTime - startTime;  // in nanoseconds

    int cpuCores = Runtime.getRuntime().availableProcessors();

    // CPU usage as a percentage of container's available CPUs
    double cpuUsagePercent = (cpuDelta * 100.0) / (timeDelta * cpuCores);

    return cpuUsagePercent;
}
