Questions on Spring Boot part- 1


Why will you choose Spring Boot over Spring Framework ?
	I would choose Spring Boot over the plain Spring Framework because it accelerates development by providing auto-configuration, embedded servers, and opinionated defaults. It comes production-ready with Actuator, easier dependency management, and starter projects, making it ideal for microservices and cloud deployments. While plain Spring gives fine-grained control, Boot removes boilerplate and helps teams deliver faster with consistent configurations.
        1. Auto-Configuration
        2. Embedded Servers
        3. Opinionated Defaults
        4. Production-Ready Features
        5. Faster Development
        6. Microservices Architecture
        7. Developer Productivity
        
What all spring boot starter you have used or what all module you have worked on ?
üîπ Core & Web
        spring-boot-starter-web ‚Üí For building REST APIs and MVC applications (Tomcat embedded by default).
        spring-boot-starter-webflux ‚Üí For reactive programming with non-blocking I/O.
        spring-boot-starter-actuator ‚Üí Health checks, metrics, and monitoring.
üîπ Data & Persistence
        spring-boot-starter-data-jpa ‚Üí ORM with Hibernate, repository abstractions.
        spring-boot-starter-data-redis ‚Üí Redis caching and data store (with Jedis or Lettuce).
        spring-boot-starter-jdbc ‚Üí Plain JDBC with connection pooling (HikariCP).
        spring-boot-starter-data-mongodb ‚Üí NoSQL document database.
üîπ Messaging
        spring-boot-starter-amqp ‚Üí RabbitMQ.
        spring-boot-starter-artemis or activemq ‚Üí JMS messaging.
        spring-cloud-starter-stream-solace / kafka / rabbit ‚Üí Event-driven microservices.
üîπ Security & Auth
        spring-boot-starter-security ‚Üí Authentication, authorization, JWTs, OAuth2.
        spring-boot-starter-oauth2-client / oauth2-resource-server ‚Üí OAuth flows.
üîπ Cloud & Microservices
        spring-cloud-starter-netflix-eureka-client ‚Üí Service discovery.
        spring-cloud-starter-config ‚Üí Centralized configuration management.
        spring-cloud-starter-gateway ‚Üí API Gateway.
        spring-cloud-starter-openfeign ‚Üí Declarative REST client.
        spring-cloud-starter-sleuth ‚Üí Distributed tracing (with Zipkin/Jaeger).
üîπ Utility
        spring-boot-starter-validation ‚Üí Bean validation with Hibernate Validator.
        spring-boot-starter-mail ‚Üí Sending emails via SMTP.
        spring-boot-starter-quartz ‚Üí Job scheduling.
        spring-boot-starter-batch ‚Üí Batch processing with retry, job repository.
        spring-boot-starter-test ‚Üí JUnit, Mockito, AssertJ for testing.


How will you run your Spring Boot application ?
        mvn spring-boot:run
        mvn clean package

        ./gradlew bootRun

        java -jar target/myapp-0.0.1-SNAPSHOT.jar


What is the purpose of the @SpringBootApplication annotation in a Spring Boot application ?
        The @SpringBootApplication annotation is a meta-annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan. It marks the class as a configuration class, enables auto-configuration of Spring beans based on dependencies, and triggers component scanning in the current package. In short, it‚Äôs the entry point that sets up a Spring Boot app with minimal configuration

        @SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan

        @SpringBootApplication(scanBasePackages = {"com.myapp", "com.sharedlib"}) --> customize
        @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) --> exclude auto-configurations




can I directly use @EnableAutoConfiguration ,@ComponentScan & @Configuration annotation in my main class , instead of using
@SpringBootApplication annotation , if yes will my application work as expected ?
        Yes, technically I can replace @SpringBootApplication with @Configuration, @EnableAutoConfiguration, and @ComponentScan, and the app will behave the same. But @SpringBootApplication is preferred because it‚Äôs cleaner, more readable, and centralizes customization. Using it also ensures forward compatibility with Spring Boot improvements. Spring Boot may enhance @SpringBootApplication with more meta-annotations in the future. If you hardcode the three separately, you won‚Äôt automatically get new features

        With @SpringBootApplication, you can tweak auto-configuration and scanning in one place:
                @SpringBootApplication(    scanBasePackages = "com.myapp",     exclude = {DataSourceAutoConfiguration.class} )
        If you split the annotations, you‚Äôll have to configure these in different places, which gets messy.

What is Auto configuration in spring boot ?
Auto-configuration is Spring Boot‚Äôs mechanism to automatically configure beans in your application context based on:
        Classpath dependencies (what libraries you‚Äôve added)
        Defined beans (your custom ones override defaults)
        External properties (application.yml / application.properties)

How can you disable a specific auto-configuration class in Spring Boot ?
        We can disable a specific auto-configuration in multiple ways. The most common is by using exclude in the @SpringBootApplication annotation, like excluding DataSourceAutoConfiguration if we want a custom DataSource. We can also disable it via spring.autoconfigure.exclude in application properties, or use @EnableAutoConfiguration(exclude=...) on a configuration class. This gives fine-grained control when Boot‚Äôs default setup clashes with our custom setup.
        1. Using exclude in @SpringBootApplication
                @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
                public class MyApplication {
                    public static void main(String[] args) {
                        SpringApplication.run(MyApplication.class, args);
                    }
                }
        2. Using excludeName (string-based)
                @SpringBootApplication(excludeName = {
                    "org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration"
                })
        3. Via application.properties / application.yml
                spring:
                  autoconfigure:
                    exclude:
                      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

How can you customize the default configuration in Spring Boot ?
	my-redis-http-starter/
	 ‚îú‚îÄ‚îÄ pom.xml
	 ‚îî‚îÄ‚îÄ src/main/java/com/example/starter/
	 ‚îÇ     ‚îú‚îÄ‚îÄ redis/
	 ‚îÇ     ‚îÇ     ‚îú‚îÄ‚îÄ MyRedisProperties.java
	 ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ MyRedisAutoConfiguration.java
	 ‚îÇ     ‚îú‚îÄ‚îÄ http/
	 ‚îÇ     ‚îÇ     ‚îú‚îÄ‚îÄ MyHttpProperties.java
	 ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ MyHttpAutoConfiguration.java
	 ‚îÇ     ‚îî‚îÄ‚îÄ client/
	 ‚îÇ           ‚îú‚îÄ‚îÄ MyRedisClient.java   // wrapper for your redis jar
	 ‚îÇ           ‚îî‚îÄ‚îÄ MyHttpClient.java    // wrapper for your http jar
	 ‚îî‚îÄ‚îÄ src/main/resources/
	       ‚îî‚îÄ‚îÄ META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

How Spring boot run() method works internally ?
	1. Create a SpringApplication instance
		SpringApplication.run() actually creates a SpringApplication object.
		It inspects your classpath:
		If it sees spring-webmvc ‚Üí configures Tomcat/Jetty/Undertow.
		If it sees spring-webflux ‚Üí configures a reactive server.
		If neither, just starts a plain application context.	
	2. Prepare the Environment
		Reads command-line arguments, application.yaml/properties, environment variables, and merges them into the Environment.
		Creates ConfigurableEnvironment (like StandardServletEnvironment for web apps).
		Publishes an event: ApplicationEnvironmentPreparedEvent.	
	3. Create & Configure the ApplicationContext
		Chooses the right context:
			AnnotationConfigServletWebServerApplicationContext (for servlet-based apps).
			AnnotationConfigReactiveWebServerApplicationContext (for reactive apps).
			AnnotationConfigApplicationContext (non-web).
			Registers beans, component scans, configuration classes.	
	4. Prepare Listeners & Initializers
		Runs all ApplicationContextInitializers (you can hook into this).
		Registers ApplicationListeners (to react to lifecycle events).
	5. Refresh the Context
		This is where the real magic happens:
		Bean definitions are loaded.
		Dependency injection is performed.
		@Configuration classes are processed.
		Auto-configuration kicks in (Spring Boot loads classes from spring.factories / AutoConfiguration.imports).
		Lifecycle methods (@PostConstruct, InitializingBean.afterPropertiesSet) run.
	6. Start the Embedded Server (if web app)
		Boot will spin up Tomcat/Jetty/Undertow automatically.
		Registers DispatcherServlet for HTTP request handling.
	7. Trigger Runners
		Runs beans that implement:
		CommandLineRunner
		ApplicationRunner
		Useful for startup logic.
	8. Application is Ready
		Publishes ApplicationReadyEvent.
		Your app is now listening for requests.

What is Command line runner in spring boot ?
	It‚Äôs a functional interface provided by Spring Boot:
		@FunctionalInterface
		public interface CommandLineRunner {
		    void run(String... args) throws Exception;
		}
	Any bean that implements this will be executed after the Spring application context is loaded and just before the app is fully up.
	üõ†Ô∏è When to Use It?
		Running initialization logic (e.g., load cache, seed database, verify connections).
		Running startup jobs like scheduling, logging startup configs.
		Quick argument-based tasks if you pass command-line args.

What is Command line runner in spring boot ?
	ApplicationRunner as the developer-friendly upgrade of CommandLineRunner. 

	It‚Äôs a Spring Boot interface (functional) that lets you run custom code after the Spring application context is fully started.
	Very similar to CommandLineRunner, but instead of giving you a raw String[] of arguments, it gives you a richer, structured object: ApplicationArguments.
	
	@FunctionalInterface
	public interface ApplicationRunner {
	    void run(ApplicationArguments args) throws Exception;
	}





Questions on Spring Boot part- 2
Can you explain the purpose of Stereotype annotations in the Spring Framework ?
	In Spring, stereotype annotations are specialized annotations used to tell the framework:
	‚û°Ô∏è ‚ÄúHey Spring, this class is a particular kind of component, please manage it as a bean in the application context.‚Äù

	| **Annotation**          | **Role (Kind of Component)** | **Extra Features / Notes**                                                                |
	| ----------------------- | ---------------------------- | ----------------------------------------------------------------------------------------- |
	| `@Component`            | Generic component            | Basic Spring bean, no extra semantics.                                                    |
	| `@Service`              | Service / Business logic     | Marks service layer classes. Helps readability & separation of concerns.                  |
	| `@Repository`           | Data Access Object (DAO)     | Adds **exception translation** (JDBC ‚Üí Spring `DataAccessException`).                     |
	| `@Controller`           | MVC Controller (Web Layer)   | Used in Spring MVC for handling web requests (returns views, not JSON).                   |
	| `@RestController`       | REST Controller              | Combines `@Controller` + `@ResponseBody`. Used for REST APIs returning JSON/XML directly. |
	| `@Configuration`        | Configuration Class          | Special component that defines **beans** with `@Bean` methods.                            |
	| `@ControllerAdvice`     | Global Controller Component  | Allows centralized exception handling / data binding across controllers.                  |
	| `@RestControllerAdvice` | REST Exception Handler       | Like `@ControllerAdvice` but specialized for REST APIs.                                   |
	| `@Indexed` (Spring 5)   | Optimized Component          | Works with `@Component` to help Spring index beans for faster startup.                    |


How can you define bean in spring framework ?
	XML ‚Üí Old-school, less used in Spring Boot.
	@Bean in @Configuration class ‚Üí Explicit bean declaration.
	@Component/@Service/etc. ‚Üí Automatic detection via scanning.
	
	1. Using XML Configuration (Old Style)
		This is the traditional way. You define beans inside applicationContext.xml or beans.xml
		<beans xmlns="http://www.springframework.org/schema/beans"
		       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		       xsi:schemaLocation="
		         http://www.springframework.org/schema/beans 
		         http://www.springframework.org/schema/beans/spring-beans.xsd">
		
		    <!-- Define a bean with id and class -->
		    <bean id="myService" class="com.example.service.MyService"/>
		</beans>
	2. Using Java-based Configuration (@Configuration + @Bean)
		Spring Boot favors this style for flexibility and type-safety.
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			@Configuration
			public class AppConfig {
			    @Bean
			    public MyService myService() {
			        return new MyService(); // Spring will manage this as a bean
			    }
			}
	3. Using Stereotype Annotations (Component Scanning)
		Spring automatically detects classes annotated with stereotypes like @Component, @Service, @Repository, or @Controller when component scanning is enabled.
		import org.springframework.stereotype.Service;
		@Service
		public class MyService {
		    public String greet() {
		        return "Hello from MyService!";
		    }
		}



What is dependency injection ?
	Dependency Injection is a design pattern in which an object (or class) receives its dependencies from an external source rather than creating them itself.
		A dependency is any object that a class needs to function.
		Instead of new-ing its dependencies inside the class, the dependencies are injected by the Spring container.
	üîπ Why Use Dependency Injection?
		Loose Coupling ‚Äì Classes don‚Äôt create or manage their dependencies.	
		Easier Testing ‚Äì You can inject mocks/stubs in unit tests.	
		Maintainability ‚Äì Changing a dependency doesn‚Äôt require modifying the class using it.	
		Configuration Flexibility ‚Äì Dependencies can be swapped via XML, Java config, or annotations.
	üîπ Types of Dependency Injection in Spring
		| Type                      | Description                                                       | Example                                                        |
		| ------------------------- | ----------------------------------------------------------------- | -------------------------------------------------------------- |
		| **Constructor Injection** | Dependencies are provided through the constructor                 | `public MyService(MyRepository repo) { this.repo = repo; }`    |
		| **Setter Injection**      | Dependencies are set via setter methods                           | `public void setRepo(MyRepository repo) { this.repo = repo; }` |
		| **Field Injection**       | Dependencies are injected directly into fields using `@Autowired` | `@Autowired private MyRepository repo;`                        |

	üîπ Example in Spring Boot
		üîπ Using Constructor Injection (Recommended)
			import org.springframework.stereotype.Service;
			@Service
			public class OrderService {
			    private final PaymentService paymentService;
			    public OrderService(PaymentService paymentService) {
			        this.paymentService = paymentService;
			    }
			    public void processOrder() {
			        paymentService.processPayment();
			    }
			}
			
			PaymentService
			import org.springframework.stereotype.Service;
			@Service
			public class PaymentService {
			    public void processPayment() {
			        System.out.println("Payment processed!");
			    }
			}
			Spring Boot automatically injects PaymentService into OrderService because both are annotated as beans (@Service).
	
		üîπ Field Injection (Not Recommended)
			@Service
			public class OrderService {
			    @Autowired
			    private PaymentService paymentService;
			    public void processOrder() {
			        paymentService.processPayment();
			    }
			}
		üîπ Setter Injection
			@Service
			public class OrderService {
			    private PaymentService paymentService;
			    @Autowired
			    public void setPaymentService(PaymentService paymentService) {
			        this.paymentService = paymentService;
			    }
			    public void processOrder() {
			        paymentService.processPayment();
			    }
			}
Compare constructor, setter and field injection?
	| Feature / Aspect                  | **Constructor Injection**                                      | **Setter Injection**                       | **Field Injection**                                            |
	| --------------------------------- | -------------------------------------------------------------- | ------------------------------------------ | -------------------------------------------------------------- |
	| **How dependencies are injected** | Via class constructor                                          | Via public setter method                   | Directly into fields with `@Autowired`                         |
	| **Immutability**                  | ‚úÖ Fully immutable (final fields possible)                      | ‚ö†Ô∏è Mutable (can change after construction) | ‚ö†Ô∏è Mutable                                                     |
	| **Mandatory dependencies**        | ‚úÖ Ensures required dependencies are set                        | ‚ö†Ô∏è Optional unless you add null checks     | ‚ö†Ô∏è Optional unless manually checked                            |
	| **Testability / Mocking**         | ‚úÖ Easy to test via constructor                                 | ‚úÖ Easy to test via setter                  | ‚ö†Ô∏è Harder to test (requires reflection or Spring test context) |
	| **Null-safety**                   | ‚úÖ Null dependencies caught at construction time                | ‚ö†Ô∏è Null checks needed                      | ‚ö†Ô∏è Null checks needed                                          |
	| **Circular dependency detection** | ‚úÖ Spring can detect circular dependencies at construction time | ‚ö†Ô∏è Circular dependency may pass silently   | ‚ö†Ô∏è Circular dependency may pass silently                       |
	| **Code readability**              | ‚úÖ Clear what dependencies are required                         | ‚ö†Ô∏è Slightly less obvious                   | ‚ö†Ô∏è Dependencies hidden in fields                               |
	| **Boilerplate code**              | ‚ö†Ô∏è Slightly more verbose                                       | ‚ö†Ô∏è Moderate                                | ‚úÖ Minimal                                                      |
	| **Spring Best Practice**          | ‚úÖ Recommended                                                  | ‚ö†Ô∏è Acceptable                              | ‚ùå Not recommended                                              |

Why Field Injection is Mutable
	üîπ With field injection, Spring sets the field via reflection after the object is constructed.
	üîπ Since the field cannot be final (final fields must be initialized in the constructor), the dependency can be modified later, either accidentally or intentionally.
	üîπ This breaks immutability, which is a core principle for reliable, thread-safe design.
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.stereotype.Component;
		@Component
		class PaymentService {
		    public void pay() {
		        System.out.println("Payment processed!");
		    }
		}
		@Component
		class OrderService {
		    // Field injection
		    @Autowired
		    private PaymentService paymentService;
		    public void processOrder() {
		        paymentService.pay();
		    }
		    // Someone can modify this dependency later
		    public void setPaymentService(PaymentService paymentService) {
		        this.paymentService = paymentService;
		    }
		}

Strategy Pattern Example
		public interface PaymentProcessor {
		    void processPayment(double amount);
		}
		import org.springframework.stereotype.Component;
		@Component("paypalProcessor")
		public class PaypalPaymentProcessor implements PaymentProcessor {
		    @Override
		    public void processPayment(double amount) {
		        System.out.println("Processed $" + amount + " via PayPal");
		    }
		}
		import org.springframework.stereotype.Component;
		@Component("stripeProcessor")
		public class StripePaymentProcessor implements PaymentProcessor {
		    @Override
		    public void processPayment(double amount) {
		        System.out.println("Processed $" + amount + " via Stripe");
		    }
		}
		import org.springframework.stereotype.Service;
		import java.util.Map;
		@Service
		public class PaymentService {
		    private final Map<String, PaymentProcessor> processorMap;
		    // Spring injects all beans implementing PaymentProcessor as a map
		    public PaymentService(Map<String, PaymentProcessor> processorMap) {
		        this.processorMap = processorMap;
		    }
		    public void makePayment(String type, double amount) {
		        PaymentProcessor processor = processorMap.get(type + "Processor"); // bean names
		        if (processor == null) {
		            throw new IllegalArgumentException("No processor found for type: " + type);
		        }
		        processor.processPayment(amount);
		    }
		}
				
		What happens internally
			Spring scans the context for all beans implementing PaymentProcessor.
			It collects them into a Map:
				Key: the bean name
				Value: the bean instance

How many ways we can perform dependency injection in spring or spring boot ?

where you would choose to use setter injection over constructor injection, and vice versa ?
	1Ô∏è‚É£ Constructor Injection (Recommended for most cases)
		‚úÖ Use Cases:
			Required Dependencies: When a dependency must always be provided for the class to function correctly.
			Immutability: You want the dependency to be final and unchangeable after creation.
			Testability: Makes unit testing easier because dependencies are explicit.
			Avoid Null References: Spring ensures the dependency is set at construction time.
			Prevent Circular Dependency: Constructor injection makes circular dependencies obvious at startup.

					@Service
					public class OrderService {					
					    private final PaymentService paymentService;					
					    @Autowired
					    public OrderService(PaymentService paymentService) {
					        this.paymentService = paymentService;
					    }					
					    public void processOrder() {
					        paymentService.pay();
					    }
						}
	2Ô∏è‚É£ Setter Injection (Optional / Flexible Dependencies)
		‚úÖ Use Cases:
			Optional Dependencies: The class can function without the dependency, but it can be injected if available.
			Late Initialization: You may want to set or override the dependency after object creation.
			Mutable Beans: When dependency might change dynamically (rare in practice).
			Avoid Breaking Legacy Code: Sometimes required in frameworks or old code where constructor injection is not feasible.
				@Service
				public class NotificationService {				
				    private EmailService emailService;				
				    @Autowired
				    public void setEmailService(EmailService emailService) {
				        this.emailService = emailService;
				    }				
				    public void sendNotification(String msg) {
				        if (emailService != null) {
				            emailService.sendEmail(msg);
				        } else {
				            System.out.println("Email service not configured");
				        }
				    }
				}

Can you provide an example of a real-world use case where @PostConstruct is particularly useful?
	@PostConstruct is very handy in real-world Spring applications for initializing beans after all dependencies are injected but before the bean is used.

How can we dynamically load values in a Spring Boot application?
	1Ô∏è‚É£ Using @Value Annotation @Value("${app.max-users}")
	2Ô∏è‚É£ Using @ConfigurationProperties
			@Component
			@ConfigurationProperties(prefix = "app")
			public class AppProperties {
	3Ô∏è‚É£ Loading from External Sources (Database / API)
	4Ô∏è‚É£ Using Spring Cloud Config (Distributed / Remote)
	5Ô∏è‚É£ Environment Object

Can you explain the key differences between YML and properties files, and in what scenarios you might prefer one format over the other?
	| Feature               | **.properties**                      | **.yml / .yaml**                                  |                                |
	| --------------------- | ------------------------------------ | ------------------------------------------------- | ------------------------------ |
	| **Structure**         | Flat, key-value pairs                | Hierarchical / nested structure using indentation |                                |
	| **Example**           | `app.name=MySpringApp`               | `yaml app: name: MySpringApp `                    |                                |
	| **Arrays / Lists**    | `servers[0]=s1` <br> `servers[1]=s2` | `yaml servers: - s1 - s2 `                        |                                |
	| **Comments**          | `# comment`                          | `# comment`                                       |                                |
	| **Multi-line values** | Use `\` for line continuation        | Use \`                                            | `or`>\` for multi-line strings |


What is the difference between yml & YAML ?
	There is no difference in content or functionality. It‚Äôs just file naming convention.

If I will configure same values in both properties then which value will be load in spring boot OR Who will load first properties or yml file ?
	Spring Boot merges .yml and .properties files.
	If a key exists in both, the last one read wins.
		In practice:
		classpath:/application.properties
		classpath:/application.yml
	.properties is loaded first, .yml is loaded after.
	So the value from YAML will override the value in properties if the same key exists.


How to load External Properties in Spring Boot ?
	1Ô∏è‚É£ Using spring.config.location or spring.config.additional-location: You can place your properties or YAML file outside the jar and tell Spring Boot where to find it.
	2Ô∏è‚É£ Using @PropertySource Annotation
		import org.springframework.context.annotation.Configuration;
		import org.springframework.context.annotation.PropertySource;
		import org.springframework.beans.factory.annotation.Value;
		@Configuration
		@PropertySource("file:/opt/config/external.properties")
		public class ExternalConfig {
		    @Value("${app.name}")
		    private String appName;
		    public String getAppName() { return appName; }
		}
	3Ô∏è‚É£ Environment Variables
		Environment variables are OS-level variables that your operating system or container provides to processes, including your Spring Boot application. Spring Boot can automatically read them and map them to configuration properties.
			Spring Boot automatically maps environment variables to properties.	
			Use uppercase with underscores for nested properties.
				export APP_NAME=EnvApp
				export APP_PORT=8086
				app:
				  name: EnvApp
				  port: 8086
	4Ô∏è‚É£ Command-Line Arguments: java -jar myapp.jar --app.name=CmdApp --app.port=8087
	5Ô∏è‚É£ Using Spring Cloud Config Server (Distributed Config)	

How to map or bind config properties to java Object ?



Questions on Spring Boot part- 3


How will you resolve bean dependency ambiguity ?
Can we avoid this dependency ambiguity without using @Qualifier ?
What is bean scope & Can you explain different type of bean scope ?
How to define custom bean scope ?
Can you provide a few real-time use cases for when to choose Singleton scope and Prototype scope ?
can we inject prototype bean in singleton bean ? if yes what will happen if we inject prototype bean in singleton bean ?
What is the difference between spring singleton and plain singleton ?
What is the purpose of the BeanPostProcessor interface in Spring, and how can you use it to customize bean initialization and destruction?
Questions on Spring Boot part- 4


Have you worked on Restful webservices ? If yes What all HTTP methods have you used in your project ?
How can you specify the HTTP method type for your REST endpoint?
Scenario : Can you design a rest endpoint , Assume that you have a Product database, and your task is to create an API to filter a list of products by productType ?
Scenario : Design endpoints in a way that takes ‚ÄúproductType‚Äù as input. If the user provides this input, the endpoint should filter products based on the specified condition. If ‚ÄúproductType‚Äù is not provided, the endpoint should return all the products. ?
What is the difference between @PathVariable & @RequestParam ?
Why did you use @RestController why not @Controller ?
How can we deserialize a JSON request payload into an object within a Spring MVC controller ?
Can we perform update operation in POST http method if yes then why do we need Put Mapping or put http method?
Can we pass Request Body in GET HTTP Method ?
How can we perform content negotiation (XML/JSON) in Rest endpoint ?
What all status code you have observed in your application ?
How can you customize the status code for your endpoint ?
How can you enable cross origin ?
How can you upload a file in spring ?
How do you maintain versioning for your REST API?
How will you document your rest API ?
How can you hide certain REST endpoints to prevent them from being exposed externally?
How will you consume restful API ?
Questions on Spring Boot part- 5


How will you handle exceptions in your project ?
How can you avoid defining handlers for multiple exceptions, or what is the best practice for handling exceptions ?
How will you validate or sanitise your input payload ?
How can you populate validation error message to the end users ?
How can you define custom bean validation ?
use case : let‚Äôs say you find a bug in production environment and now you want to debug that scenario ,How can you do that from your local ?
How can you enable a specific environment without using profiles? OR what is the alternative to profiles to achieving same use case ?
What is the difference between @Profile & @ConditioOnXXX ?
What is AOP ?
What is pointcut & join Points in AOP ?
What are different type of advice ?
use case ‚Äî can I use AOP to evaluate performance of a method or is this possible to design a logging framework to capture request and response body of a method ?
Questions on Spring Boot part- 6


How does your application interact with the database and which frameworks are you using?
Why is it important to configure a physical naming strategy?
What are the key benefits of using Spring Data JPA ?
What are the differences between Hibernate, JPA, and Spring Data JPA?
How can you connect multiple databases or data sources in a single application?
What are the different ways to define custom queries in Spring Data JPA ?
Can you provide example to find results based on some range
Ex 1 : Find list of employees whose age in between 30 lakh to 35 lakh
Ex 2 : find avg salary of employees in an organization

8. How will you define entity relationships or association mapping in Spring Data JPA?

(Use Case: Consider an e-commerce application where each customer can have multiple orders. Here, a Customer entity can be associated with multiple Order entities.)

9. Is this possible to execute Join query in Spring Data JPA ? If yes, how can you add some insights ?

10. How will you implement pagination & Sorting in Spring Data JPA ?

Questions on Spring Boot part- 7


How will you handle auditing in your application ?
Explain Different annotation used for auditing
How can auditing be applied in a NoSQL database like MongoDB in Spring Boot?
How can we customize auditing in Spring Boot ?
How do you track entity modifications across different users in a microservices architecture, and how can a centralized audit service help with cross-service auditing?
What is transaction management and how it works ?
How will you handle transaction in your application ?
What are different type of Isolation and Propagation ?
Can we use transaction in private methods ?
How will you handle transaction in distributed microservice ?
Can we use transaction in multiple microservices why or why not ?
NOTE : This blog will continue with regular uploads of questions from various modules of Spring Boot. You will receive notifications if you follow the JavaTechie Medium

Spring Boot In-depth Interview Q&A
