Questions on Spring Boot part- 1


Why will you choose Spring Boot over Spring Framework ?
	I would choose Spring Boot over the plain Spring Framework because it accelerates development by providing auto-configuration, embedded servers, and opinionated defaults. It comes production-ready with Actuator, easier dependency management, and starter projects, making it ideal for microservices and cloud deployments. While plain Spring gives fine-grained control, Boot removes boilerplate and helps teams deliver faster with consistent configurations.
        1. Auto-Configuration
        2. Embedded Servers
        3. Opinionated Defaults
        4. Production-Ready Features
        5. Faster Development
        6. Microservices Architecture
        7. Developer Productivity
        
What all spring boot starter you have used or what all module you have worked on ?
üîπ Core & Web
        spring-boot-starter-web ‚Üí For building REST APIs and MVC applications (Tomcat embedded by default).
        spring-boot-starter-webflux ‚Üí For reactive programming with non-blocking I/O.
        spring-boot-starter-actuator ‚Üí Health checks, metrics, and monitoring.
üîπ Data & Persistence
        spring-boot-starter-data-jpa ‚Üí ORM with Hibernate, repository abstractions.
        spring-boot-starter-data-redis ‚Üí Redis caching and data store (with Jedis or Lettuce).
        spring-boot-starter-jdbc ‚Üí Plain JDBC with connection pooling (HikariCP).
        spring-boot-starter-data-mongodb ‚Üí NoSQL document database.
üîπ Messaging
        spring-boot-starter-amqp ‚Üí RabbitMQ.
        spring-boot-starter-artemis or activemq ‚Üí JMS messaging.
        spring-cloud-starter-stream-solace / kafka / rabbit ‚Üí Event-driven microservices.
üîπ Security & Auth
        spring-boot-starter-security ‚Üí Authentication, authorization, JWTs, OAuth2.
        spring-boot-starter-oauth2-client / oauth2-resource-server ‚Üí OAuth flows.
üîπ Cloud & Microservices
        spring-cloud-starter-netflix-eureka-client ‚Üí Service discovery.
        spring-cloud-starter-config ‚Üí Centralized configuration management.
        spring-cloud-starter-gateway ‚Üí API Gateway.
        spring-cloud-starter-openfeign ‚Üí Declarative REST client.
        spring-cloud-starter-sleuth ‚Üí Distributed tracing (with Zipkin/Jaeger).
üîπ Utility
        spring-boot-starter-validation ‚Üí Bean validation with Hibernate Validator.
        spring-boot-starter-mail ‚Üí Sending emails via SMTP.
        spring-boot-starter-quartz ‚Üí Job scheduling.
        spring-boot-starter-batch ‚Üí Batch processing with retry, job repository.
        spring-boot-starter-test ‚Üí JUnit, Mockito, AssertJ for testing.


How will you run your Spring Boot application ?
        mvn spring-boot:run
        mvn clean package

        ./gradlew bootRun

        java -jar target/myapp-0.0.1-SNAPSHOT.jar


What is the purpose of the @SpringBootApplication annotation in a Spring Boot application ?
        The @SpringBootApplication annotation is a meta-annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan. It marks the class as a configuration class, enables auto-configuration of Spring beans based on dependencies, and triggers component scanning in the current package. In short, it‚Äôs the entry point that sets up a Spring Boot app with minimal configuration

        @SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan

        @SpringBootApplication(scanBasePackages = {"com.myapp", "com.sharedlib"}) --> customize
        @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) --> exclude auto-configurations




can I directly use @EnableAutoConfiguration ,@ComponentScan & @Configuration annotation in my main class , instead of using
@SpringBootApplication annotation , if yes will my application work as expected ?
        Yes, technically I can replace @SpringBootApplication with @Configuration, @EnableAutoConfiguration, and @ComponentScan, and the app will behave the same. But @SpringBootApplication is preferred because it‚Äôs cleaner, more readable, and centralizes customization. Using it also ensures forward compatibility with Spring Boot improvements. Spring Boot may enhance @SpringBootApplication with more meta-annotations in the future. If you hardcode the three separately, you won‚Äôt automatically get new features

        With @SpringBootApplication, you can tweak auto-configuration and scanning in one place:
                @SpringBootApplication(    scanBasePackages = "com.myapp",     exclude = {DataSourceAutoConfiguration.class} )
        If you split the annotations, you‚Äôll have to configure these in different places, which gets messy.

What is Auto configuration in spring boot ?
Auto-configuration is Spring Boot‚Äôs mechanism to automatically configure beans in your application context based on:
        Classpath dependencies (what libraries you‚Äôve added)
        Defined beans (your custom ones override defaults)
        External properties (application.yml / application.properties)

How can you disable a specific auto-configuration class in Spring Boot ?
        We can disable a specific auto-configuration in multiple ways. The most common is by using exclude in the @SpringBootApplication annotation, like excluding DataSourceAutoConfiguration if we want a custom DataSource. We can also disable it via spring.autoconfigure.exclude in application properties, or use @EnableAutoConfiguration(exclude=...) on a configuration class. This gives fine-grained control when Boot‚Äôs default setup clashes with our custom setup.
        1. Using exclude in @SpringBootApplication
                @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
                public class MyApplication {
                    public static void main(String[] args) {
                        SpringApplication.run(MyApplication.class, args);
                    }
                }
        2. Using excludeName (string-based)
                @SpringBootApplication(excludeName = {
                    "org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration"
                })
        3. Via application.properties / application.yml
                spring:
                  autoconfigure:
                    exclude:
                      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

How can you customize the default configuration in Spring Boot ?
	my-redis-http-starter/
	 ‚îú‚îÄ‚îÄ pom.xml
	 ‚îî‚îÄ‚îÄ src/main/java/com/example/starter/
	 ‚îÇ     ‚îú‚îÄ‚îÄ redis/
	 ‚îÇ     ‚îÇ     ‚îú‚îÄ‚îÄ MyRedisProperties.java
	 ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ MyRedisAutoConfiguration.java
	 ‚îÇ     ‚îú‚îÄ‚îÄ http/
	 ‚îÇ     ‚îÇ     ‚îú‚îÄ‚îÄ MyHttpProperties.java
	 ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ MyHttpAutoConfiguration.java
	 ‚îÇ     ‚îî‚îÄ‚îÄ client/
	 ‚îÇ           ‚îú‚îÄ‚îÄ MyRedisClient.java   // wrapper for your redis jar
	 ‚îÇ           ‚îî‚îÄ‚îÄ MyHttpClient.java    // wrapper for your http jar
	 ‚îî‚îÄ‚îÄ src/main/resources/
	       ‚îî‚îÄ‚îÄ META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

How Spring boot run() method works internally ?
	1. Create a SpringApplication instance
		SpringApplication.run() actually creates a SpringApplication object.
		It inspects your classpath:
		If it sees spring-webmvc ‚Üí configures Tomcat/Jetty/Undertow.
		If it sees spring-webflux ‚Üí configures a reactive server.
		If neither, just starts a plain application context.	
	2. Prepare the Environment
		Reads command-line arguments, application.yaml/properties, environment variables, and merges them into the Environment.
		Creates ConfigurableEnvironment (like StandardServletEnvironment for web apps).
		Publishes an event: ApplicationEnvironmentPreparedEvent.	
	3. Create & Configure the ApplicationContext
		Chooses the right context:
			AnnotationConfigServletWebServerApplicationContext (for servlet-based apps).
			AnnotationConfigReactiveWebServerApplicationContext (for reactive apps).
			AnnotationConfigApplicationContext (non-web).
			Registers beans, component scans, configuration classes.	
	4. Prepare Listeners & Initializers
		Runs all ApplicationContextInitializers (you can hook into this).
		Registers ApplicationListeners (to react to lifecycle events).
	5. Refresh the Context
		This is where the real magic happens:
		Bean definitions are loaded.
		Dependency injection is performed.
		@Configuration classes are processed.
		Auto-configuration kicks in (Spring Boot loads classes from spring.factories / AutoConfiguration.imports).
		Lifecycle methods (@PostConstruct, InitializingBean.afterPropertiesSet) run.
	6. Start the Embedded Server (if web app)
		Boot will spin up Tomcat/Jetty/Undertow automatically.
		Registers DispatcherServlet for HTTP request handling.
	7. Trigger Runners
		Runs beans that implement:
		CommandLineRunner
		ApplicationRunner
		Useful for startup logic.
	8. Application is Ready
		Publishes ApplicationReadyEvent.
		Your app is now listening for requests.

What is Command line runner in spring boot ?
	It‚Äôs a functional interface provided by Spring Boot:
		@FunctionalInterface
		public interface CommandLineRunner {
		    void run(String... args) throws Exception;
		}
	Any bean that implements this will be executed after the Spring application context is loaded and just before the app is fully up.
	üõ†Ô∏è When to Use It?
		Running initialization logic (e.g., load cache, seed database, verify connections).
		Running startup jobs like scheduling, logging startup configs.
		Quick argument-based tasks if you pass command-line args.

What is Command line runner in spring boot ?
	ApplicationRunner as the developer-friendly upgrade of CommandLineRunner. 

	It‚Äôs a Spring Boot interface (functional) that lets you run custom code after the Spring application context is fully started.
	Very similar to CommandLineRunner, but instead of giving you a raw String[] of arguments, it gives you a richer, structured object: ApplicationArguments.
	
	@FunctionalInterface
	public interface ApplicationRunner {
	    void run(ApplicationArguments args) throws Exception;
	}





Questions on Spring Boot part- 2
Can you explain the purpose of Stereotype annotations in the Spring Framework ?
	In Spring, stereotype annotations are specialized annotations used to tell the framework:
	‚û°Ô∏è ‚ÄúHey Spring, this class is a particular kind of component, please manage it as a bean in the application context.‚Äù

	| **Annotation**          | **Role (Kind of Component)** | **Extra Features / Notes**                                                                |
	| ----------------------- | ---------------------------- | ----------------------------------------------------------------------------------------- |
	| `@Component`            | Generic component            | Basic Spring bean, no extra semantics.                                                    |
	| `@Service`              | Service / Business logic     | Marks service layer classes. Helps readability & separation of concerns.                  |
	| `@Repository`           | Data Access Object (DAO)     | Adds **exception translation** (JDBC ‚Üí Spring `DataAccessException`).                     |
	| `@Controller`           | MVC Controller (Web Layer)   | Used in Spring MVC for handling web requests (returns views, not JSON).                   |
	| `@RestController`       | REST Controller              | Combines `@Controller` + `@ResponseBody`. Used for REST APIs returning JSON/XML directly. |
	| `@Configuration`        | Configuration Class          | Special component that defines **beans** with `@Bean` methods.                            |
	| `@ControllerAdvice`     | Global Controller Component  | Allows centralized exception handling / data binding across controllers.                  |
	| `@RestControllerAdvice` | REST Exception Handler       | Like `@ControllerAdvice` but specialized for REST APIs.                                   |
	| `@Indexed` (Spring 5)   | Optimized Component          | Works with `@Component` to help Spring index beans for faster startup.                    |


How can you define bean in spring framework ?
	XML ‚Üí Old-school, less used in Spring Boot.
	@Bean in @Configuration class ‚Üí Explicit bean declaration.
	@Component/@Service/etc. ‚Üí Automatic detection via scanning.
	
	1. Using XML Configuration (Old Style)
		This is the traditional way. You define beans inside applicationContext.xml or beans.xml
		<beans xmlns="http://www.springframework.org/schema/beans"
		       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		       xsi:schemaLocation="
		         http://www.springframework.org/schema/beans 
		         http://www.springframework.org/schema/beans/spring-beans.xsd">
		
		    <!-- Define a bean with id and class -->
		    <bean id="myService" class="com.example.service.MyService"/>
		</beans>
	2. Using Java-based Configuration (@Configuration + @Bean)
		Spring Boot favors this style for flexibility and type-safety.
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			@Configuration
			public class AppConfig {
			    @Bean
			    public MyService myService() {
			        return new MyService(); // Spring will manage this as a bean
			    }
			}
	3. Using Stereotype Annotations (Component Scanning)
		Spring automatically detects classes annotated with stereotypes like @Component, @Service, @Repository, or @Controller when component scanning is enabled.
		import org.springframework.stereotype.Service;
		@Service
		public class MyService {
		    public String greet() {
		        return "Hello from MyService!";
		    }
		}



What is dependency injection ?
	Dependency Injection is a design pattern in which an object (or class) receives its dependencies from an external source rather than creating them itself.
		A dependency is any object that a class needs to function.
		Instead of new-ing its dependencies inside the class, the dependencies are injected by the Spring container.
	üîπ Why Use Dependency Injection?
		Loose Coupling ‚Äì Classes don‚Äôt create or manage their dependencies.	
		Easier Testing ‚Äì You can inject mocks/stubs in unit tests.	
		Maintainability ‚Äì Changing a dependency doesn‚Äôt require modifying the class using it.	
		Configuration Flexibility ‚Äì Dependencies can be swapped via XML, Java config, or annotations.
	üîπ Types of Dependency Injection in Spring
		| Type                      | Description                                                       | Example                                                        |
		| ------------------------- | ----------------------------------------------------------------- | -------------------------------------------------------------- |
		| **Constructor Injection** | Dependencies are provided through the constructor                 | `public MyService(MyRepository repo) { this.repo = repo; }`    |
		| **Setter Injection**      | Dependencies are set via setter methods                           | `public void setRepo(MyRepository repo) { this.repo = repo; }` |
		| **Field Injection**       | Dependencies are injected directly into fields using `@Autowired` | `@Autowired private MyRepository repo;`                        |

	üîπ Example in Spring Boot
		üîπ Using Constructor Injection (Recommended)
			import org.springframework.stereotype.Service;
			@Service
			public class OrderService {
			    private final PaymentService paymentService;
			    public OrderService(PaymentService paymentService) {
			        this.paymentService = paymentService;
			    }
			    public void processOrder() {
			        paymentService.processPayment();
			    }
			}
			
			PaymentService
			import org.springframework.stereotype.Service;
			@Service
			public class PaymentService {
			    public void processPayment() {
			        System.out.println("Payment processed!");
			    }
			}
			Spring Boot automatically injects PaymentService into OrderService because both are annotated as beans (@Service).
	
		üîπ Field Injection (Not Recommended)
			@Service
			public class OrderService {
			    @Autowired
			    private PaymentService paymentService;
			    public void processOrder() {
			        paymentService.processPayment();
			    }
			}
		üîπ Setter Injection
			@Service
			public class OrderService {
			    private PaymentService paymentService;
			    @Autowired
			    public void setPaymentService(PaymentService paymentService) {
			        this.paymentService = paymentService;
			    }
			    public void processOrder() {
			        paymentService.processPayment();
			    }
			}
Compare constructor, setter and field injection?
	| Feature / Aspect                  | **Constructor Injection**                                      | **Setter Injection**                       | **Field Injection**                                            |
	| --------------------------------- | -------------------------------------------------------------- | ------------------------------------------ | -------------------------------------------------------------- |
	| **How dependencies are injected** | Via class constructor                                          | Via public setter method                   | Directly into fields with `@Autowired`                         |
	| **Immutability**                  | ‚úÖ Fully immutable (final fields possible)                      | ‚ö†Ô∏è Mutable (can change after construction) | ‚ö†Ô∏è Mutable                                                     |
	| **Mandatory dependencies**        | ‚úÖ Ensures required dependencies are set                        | ‚ö†Ô∏è Optional unless you add null checks     | ‚ö†Ô∏è Optional unless manually checked                            |
	| **Testability / Mocking**         | ‚úÖ Easy to test via constructor                                 | ‚úÖ Easy to test via setter                  | ‚ö†Ô∏è Harder to test (requires reflection or Spring test context) |
	| **Null-safety**                   | ‚úÖ Null dependencies caught at construction time                | ‚ö†Ô∏è Null checks needed                      | ‚ö†Ô∏è Null checks needed                                          |
	| **Circular dependency detection** | ‚úÖ Spring can detect circular dependencies at construction time | ‚ö†Ô∏è Circular dependency may pass silently   | ‚ö†Ô∏è Circular dependency may pass silently                       |
	| **Code readability**              | ‚úÖ Clear what dependencies are required                         | ‚ö†Ô∏è Slightly less obvious                   | ‚ö†Ô∏è Dependencies hidden in fields                               |
	| **Boilerplate code**              | ‚ö†Ô∏è Slightly more verbose                                       | ‚ö†Ô∏è Moderate                                | ‚úÖ Minimal                                                      |
	| **Spring Best Practice**          | ‚úÖ Recommended                                                  | ‚ö†Ô∏è Acceptable                              | ‚ùå Not recommended                                              |

Why Field Injection is Mutable
	üîπ With field injection, Spring sets the field via reflection after the object is constructed.
	üîπ Since the field cannot be final (final fields must be initialized in the constructor), the dependency can be modified later, either accidentally or intentionally.
	üîπ This breaks immutability, which is a core principle for reliable, thread-safe design.
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.stereotype.Component;
		@Component
		class PaymentService {
		    public void pay() {
		        System.out.println("Payment processed!");
		    }
		}
		@Component
		class OrderService {
		    // Field injection
		    @Autowired
		    private PaymentService paymentService;
		    public void processOrder() {
		        paymentService.pay();
		    }
		    // Someone can modify this dependency later
		    public void setPaymentService(PaymentService paymentService) {
		        this.paymentService = paymentService;
		    }
		}

Strategy Pattern Example
		public interface PaymentProcessor {
		    void processPayment(double amount);
		}
		import org.springframework.stereotype.Component;
		@Component("paypalProcessor")
		public class PaypalPaymentProcessor implements PaymentProcessor {
		    @Override
		    public void processPayment(double amount) {
		        System.out.println("Processed $" + amount + " via PayPal");
		    }
		}
		import org.springframework.stereotype.Component;
		@Component("stripeProcessor")
		public class StripePaymentProcessor implements PaymentProcessor {
		    @Override
		    public void processPayment(double amount) {
		        System.out.println("Processed $" + amount + " via Stripe");
		    }
		}
		import org.springframework.stereotype.Service;
		import java.util.Map;
		@Service
		public class PaymentService {
		    private final Map<String, PaymentProcessor> processorMap;
		    // Spring injects all beans implementing PaymentProcessor as a map
		    public PaymentService(Map<String, PaymentProcessor> processorMap) {
		        this.processorMap = processorMap;
		    }
		    public void makePayment(String type, double amount) {
		        PaymentProcessor processor = processorMap.get(type + "Processor"); // bean names
		        if (processor == null) {
		            throw new IllegalArgumentException("No processor found for type: " + type);
		        }
		        processor.processPayment(amount);
		    }
		}
				
		What happens internally
			Spring scans the context for all beans implementing PaymentProcessor.
			It collects them into a Map:
				Key: the bean name
				Value: the bean instance

How many ways we can perform dependency injection in spring or spring boot ?

where you would choose to use setter injection over constructor injection, and vice versa ?
	1Ô∏è‚É£ Constructor Injection (Recommended for most cases)
		‚úÖ Use Cases:
			Required Dependencies: When a dependency must always be provided for the class to function correctly.
			Immutability: You want the dependency to be final and unchangeable after creation.
			Testability: Makes unit testing easier because dependencies are explicit.
			Avoid Null References: Spring ensures the dependency is set at construction time.
			Prevent Circular Dependency: Constructor injection makes circular dependencies obvious at startup.

					@Service
					public class OrderService {					
					    private final PaymentService paymentService;					
					    @Autowired
					    public OrderService(PaymentService paymentService) {
					        this.paymentService = paymentService;
					    }					
					    public void processOrder() {
					        paymentService.pay();
					    }
						}
	2Ô∏è‚É£ Setter Injection (Optional / Flexible Dependencies)
		‚úÖ Use Cases:
			Optional Dependencies: The class can function without the dependency, but it can be injected if available.
			Late Initialization: You may want to set or override the dependency after object creation.
			Mutable Beans: When dependency might change dynamically (rare in practice).
			Avoid Breaking Legacy Code: Sometimes required in frameworks or old code where constructor injection is not feasible.
				@Service
				public class NotificationService {				
				    private EmailService emailService;				
				    @Autowired
				    public void setEmailService(EmailService emailService) {
				        this.emailService = emailService;
				    }				
				    public void sendNotification(String msg) {
				        if (emailService != null) {
				            emailService.sendEmail(msg);
				        } else {
				            System.out.println("Email service not configured");
				        }
				    }
				}

Can you provide an example of a real-world use case where @PostConstruct is particularly useful?
	@PostConstruct is very handy in real-world Spring applications for initializing beans after all dependencies are injected but before the bean is used.

How can we dynamically load values in a Spring Boot application?
	1Ô∏è‚É£ Using @Value Annotation @Value("${app.max-users}")
	2Ô∏è‚É£ Using @ConfigurationProperties
			@Component
			@ConfigurationProperties(prefix = "app")
			public class AppProperties {
	3Ô∏è‚É£ Loading from External Sources (Database / API)
	4Ô∏è‚É£ Using Spring Cloud Config (Distributed / Remote)
	5Ô∏è‚É£ Environment Object

Can you explain the key differences between YML and properties files, and in what scenarios you might prefer one format over the other?
	| Feature               | **.properties**                      | **.yml / .yaml**                                  |                                |
	| --------------------- | ------------------------------------ | ------------------------------------------------- | ------------------------------ |
	| **Structure**         | Flat, key-value pairs                | Hierarchical / nested structure using indentation |                                |
	| **Example**           | `app.name=MySpringApp`               | `yaml app: name: MySpringApp `                    |                                |
	| **Arrays / Lists**    | `servers[0]=s1` <br> `servers[1]=s2` | `yaml servers: - s1 - s2 `                        |                                |
	| **Comments**          | `# comment`                          | `# comment`                                       |                                |
	| **Multi-line values** | Use `\` for line continuation        | Use \`                                            | `or`>\` for multi-line strings |


What is the difference between yml & YAML ?
	There is no difference in content or functionality. It‚Äôs just file naming convention.

If I will configure same values in both properties then which value will be load in spring boot OR Who will load first properties or yml file ?
	Spring Boot merges .yml and .properties files.
	If a key exists in both, the last one read wins.
		In practice:
		classpath:/application.properties
		classpath:/application.yml
	.properties is loaded first, .yml is loaded after.
	So the value from YAML will override the value in properties if the same key exists.


How to load External Properties in Spring Boot ?
	1Ô∏è‚É£ Using spring.config.location or spring.config.additional-location: You can place your properties or YAML file outside the jar and tell Spring Boot where to find it.
	2Ô∏è‚É£ Using @PropertySource Annotation
		import org.springframework.context.annotation.Configuration;
		import org.springframework.context.annotation.PropertySource;
		import org.springframework.beans.factory.annotation.Value;
		@Configuration
		@PropertySource("file:/opt/config/external.properties")
		public class ExternalConfig {
		    @Value("${app.name}")
		    private String appName;
		    public String getAppName() { return appName; }
		}
	3Ô∏è‚É£ Environment Variables
		Environment variables are OS-level variables that your operating system or container provides to processes, including your Spring Boot application. Spring Boot can automatically read them and map them to configuration properties.
			Spring Boot automatically maps environment variables to properties.	
			Use uppercase with underscores for nested properties.
				export APP_NAME=EnvApp
				export APP_PORT=8086
				app:
				  name: EnvApp
				  port: 8086
	4Ô∏è‚É£ Command-Line Arguments: java -jar myapp.jar --app.name=CmdApp --app.port=8087
	5Ô∏è‚É£ Using Spring Cloud Config Server (Distributed Config)	

How to map or bind config properties to java Object ?



Questions on Spring Boot part- 3


How will you resolve bean dependency ambiguity ?
Can we avoid this dependency ambiguity without using @Qualifier ?
What is bean scope & Can you explain different type of bean scope ?
How to define custom bean scope ?
Can you provide a few real-time use cases for when to choose Singleton scope and Prototype scope ?
can we inject prototype bean in singleton bean ? if yes what will happen if we inject prototype bean in singleton bean ?
What is the difference between spring singleton and plain singleton ?
What is the purpose of the BeanPostProcessor interface in Spring, and how can you use it to customize bean initialization and destruction?





Questions on Spring Boot part- 4
Have you worked on Restful webservices ? If yes What all HTTP methods have you used in your project ?
	POST, PUT (full update), GET, DELETE, PATCH (Partial update), OPTIONS

Explain CORS?
in most real-world setups the frontend and backend are deployed under different DNS (like app.company.com and api.company.com). Since the browser considers them different origins, we need CORS in the backend to explicitly allow requests from the frontend domain."

	@CrossOrigin(origins = "https://app.mycompany.com")
	@RestController
	@RequestMapping("/api/users")
	public class UserController {
		// Your endpoints
	}
		
How can you specify the HTTP method type for your REST endpoint?

1) GET		@GetMapping	java @GetMapping("/users") public List<User> getUsers() { ... }
2) POST	@PostMapping	java @PostMapping("/users") public User createUser(@RequestBody User user) { ... }
3) PUT		@PutMapping	java @PutMapping("/users/{id}") public User updateUser(@PathVariable Long id, @RequestBody User user) { ... }
4) PATCH	@PatchMapping	java @PatchMapping("/users/{id}") public User updateEmail(@PathVariable Long id, @RequestBody Map<String,String> fields) { ... }
5) DELETE	@DeleteMapping	java @DeleteMapping("/users/{id}") public void deleteUser(@PathVariable Long id) { ... }

	@RequestMapping(value = "/users", method = RequestMethod.GET)
	public List<User> getUsers() {
		return List.of(new User(1L, "John"));
	}

	@RequestMapping(value = "/users", method = RequestMethod.POST)
	public User createUser(@RequestBody User user) {
		return user;
	}
	
	@RequestMapping = flexible, generic mapping
	Use @RequestMapping when you need:
		Multiple HTTP methods on same endpoint
		Header, param, content-type conditions
		Legacy compatibility

If you omit the method type in @RequestMapping, it will accept all HTTP methods ‚Üí usually not recommended.



Scenario : Can you design a rest endpoint , Assume that you have a Product database, and your task is to create an API to filter a list of products by productType ?
	@GetMapping
	public Page<Product> getProductsByType(
			@RequestParam(required = false) String productType,
			@RequestParam(defaultValue = "0") int page,
			@RequestParam(defaultValue = "10") int size) {
		Pageable pageable = PageRequest.of(page, size);
		return service.getProductsByType(productType, pageable);
	}




Scenario : Design endpoints in a way that takes ‚ÄúproductType‚Äù as input. If the user provides this input, the endpoint should filter products based on the specified condition. If ‚ÄúproductType‚Äù is not provided, the endpoint should return all the products. ?
	@GetMapping
	public List<Product> getProducts(@RequestParam(required = false) String productType) {
		return service.getProducts(productType);
	}


What is the difference between @PathVariable & @RequestParam ?
| Feature                  | `@PathVariable`                                         | `@RequestParam`                                                           |
| ------------------------ | ------------------------------------------------------- | ------------------------------------------------------------------------- |
| **Definition**           | Binds a method parameter to a **value in the URI path** | Binds a method parameter to a **query parameter in the URL** or form data |
| **Source**               | URI path segment                                        | Query string (`?key=value`) or form data                                  |
| **Optional**             | Usually **required**                                    | Can be **optional** (`required=false`)                                    |
| **Default Value**        | Cannot have default value directly                      | Can specify default value (`defaultValue="..."`)                          |
| **Use Case**             | Identify a resource                                     | Filtering, sorting, paging, optional parameters                           |
| **Example URL**          | `/products/123`                                         | `/products?productType=Electronics`                                       |
| **Annotation Usage**     | `@PathVariable Long id`                                 | `@RequestParam String productType`                                        |
| **Typical Scenario**     | `GET /products/{id}` ‚Üí get product by ID                | `GET /products?productType=Electronics` ‚Üí filter products                 |
| **Multiplicity**         | Usually one per path segment                            | Can have multiple query params in same request                            |
| **Idempotency/Behavior** | Identifies a unique resource                            | Usually optional input affecting output                                   |




Why did you use @RestController why not @Controller ?
| Feature                 | `@Controller`                                        | `@RestController`                                                 |
| ----------------------- | ---------------------------------------------------- | ----------------------------------------------------------------- |
| **Purpose**             | MVC controller, returns **views** (HTML/JSP)         | REST controller, returns **data** (JSON/XML)                      |
| **Response Handling**   | Uses **ViewResolver** to render pages                | Uses **@ResponseBody** implicitly, serializes objects to JSON/XML |
| **Annotation Required** | `@ResponseBody` needed on each method to return JSON | `@ResponseBody` is implicit, no need to annotate each method      |
| **Use Case**            | Traditional web apps with server-side rendering      | RESTful APIs / microservices / SPA backend                        |



How can we deserialize a JSON request payload into an object within a Spring MVC controller ?
	@PostMapping
	public Product createProduct(@Valid @RequestBody Product product) { ... }


Can we perform update operation in POST http method if yes then why do we need Put Mapping or put http method?
	You can technically perform an update using a POST request, but it‚Äôs not recommended. Let‚Äôs break it down clearly:
	

Can we pass Request Body in GET HTTP Method ?
	HTTP 1.1 specification allows a GET request to have a body, but in practice, it‚Äôs not recommended and almost never used

Why GET with Body is discouraged
	Caching issues: GET requests are cached, but caches usually ignore the body.
	Proxies / intermediaries may drop the body.
	Not standard practice ‚Üí can break REST semantics.
	
How can we perform content negotiation (XML/JSON) in Rest endpoint ?
	Content negotiation allows a REST API to return responses in different formats (like JSON, XML) depending on what the client asks for.
	
	1Ô∏è) Request Format (Content-Type) - Content-Type: application/json
	2) Response Format (Accept) - The client indicates the desired format using the Accept HTTP header:


What all status code you have observed in your application ?

How can you customize the status code for your endpoint ?
	1) The most common approach is to use ResponseEntity, which allows you to set the status code, headers, and body explicitly.
		@PostMapping("/products")
		public ResponseEntity<Product> createProduct(@RequestBody Product product) {
			Product savedProduct = productService.save(product);
			return ResponseEntity
					.status(HttpStatus.CREATED)   // Set custom status code
					.body(savedProduct);          // Response body
		}
	2) Using @ResponseStatus on Method --> If you don‚Äôt need dynamic status codes, you can use @ResponseStatus on the method to set a fixed status.
		@PostMapping("/products")
		@ResponseStatus(HttpStatus.CREATED)
		public Product createProduct(@RequestBody Product product) {
			return productService.save(product);
		}
	3) Using @ControllerAdvice + @ExceptionHandler --> For global exception handling, you can map exceptions to status codes centrally.
		@ControllerAdvice
		public class GlobalExceptionHandler {

			@ExceptionHandler(ProductNotFoundException.class)
			public ResponseEntity<String> handleNotFound(ProductNotFoundException ex) {
				return ResponseEntity
						.status(HttpStatus.NOT_FOUND)
						.body(ex.getMessage());
			}

			@ExceptionHandler(InvalidRequestException.class)
			public ResponseEntity<String> handleBadRequest(InvalidRequestException ex) {
				return ResponseEntity
						.status(HttpStatus.BAD_REQUEST)
						.body(ex.getMessage());
			}
		}
	4) Using @ResponseStatus on Exception Classes --> For custom exceptions, you can annotate the exception class to return a specific status code when thrown.
		@ResponseStatus(HttpStatus.NOT_FOUND)
		public class ProductNotFoundException extends RuntimeException {
			public ProductNotFoundException(String message) {
				super(message);
			}
		}
		
		In Controller:
		===================================================
		@GetMapping("/products/{id}")
		public Product getProduct(@PathVariable Long id) {
			return productService.findById(id)
					.orElseThrow(() -> new ProductNotFoundException("Product not found"));
		}



How can you upload a file in spring ?
 Enable Multipart Support
	spring.servlet.multipart.enabled=true
	spring.servlet.multipart.max-file-size=10MB
	spring.servlet.multipart.max-request-size=20MB
	
	Controller Example
	==========================================================
	@PostMapping("/upload")
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("File is empty");
        }

        try {
            // Save file locally
            byte[] bytes = file.getBytes();
            Path path = Paths.get(UPLOAD_DIR + file.getOriginalFilename());
            Files.createDirectories(path.getParent());
            Files.write(path, bytes);

            return ResponseEntity.ok("File uploaded successfully: " + file.getOriginalFilename());
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Failed to upload file");
        }
    }

	@PostMapping("/upload")
	public ResponseEntity<String> uploadFile(
			@RequestParam("file") MultipartFile file,
			@RequestParam("description") String description) { ... }


How do you maintain versioning for your REST API?
	I usually maintain versioning using the URL path (e.g., /api/v1/products). This approach is clear, easy to cache, and clients can explicitly choose which version to use. For more advanced scenarios, header or media type versioning can also be implemented to keep URLs clean while supporting multiple versions.
	
	Option 1: URL Versioning (Path Versioning)
		@RestController
		@RequestMapping("/api/v1/products")
		public class ProductV1Controller {

			@GetMapping
			public List<Product> getProducts() {
				return productService.getProductsV1();
			}
		}

		@RestController
		@RequestMapping("/api/v2/products")
		public class ProductV2Controller {

	Option 2: Request Parameter Versioning (Send the version as a query parameter.)
		@GetMapping(value = "/products", params = "version=1")
		public List<Product> getProductsV1() { ... }

		@GetMapping(value = "/products", params = "version=2")
		public List<Product> getProductsV2() { ... }

	Option 3: Header Versioning	(Send version info in custom header)
		@GetMapping(value = "/products", headers = "X-API-VERSION=1")
		public List<Product> getProductsV1() { ... }

		@GetMapping(value = "/products", headers = "X-API-VERSION=2")
		public List<Product> getProductsV2() { ... }
	
	Option 4: Media Type Versioning (Content Negotiation)
		@GetMapping(value = "/products", produces = "application/vnd.company.app-v1+json")
		public List<Product> getProductsV1() { ... }

		@GetMapping(value = "/products", produces = "application/vnd.company.app-v2+json")
		public List<Product> getProductsV2() { ... }



How will you document your rest API ?
	1) Swagger/Open API, 
	2) Spring REST Docs (Alternative): Generates asciidoc or HTML documentation from unit/integration tests
	3) Manual Documentation: Create README.md or Confluence page describing
	
How can you hide certain REST endpoints to prevent them from being exposed externally?
	1Ô∏è) Separate Public and Internal Controllers
		Organize internal APIs in a separate package (e.g., com.example.internal).
		Only scan and expose the public APIs in the main application context if needed.		
			@SpringBootApplication(scanBasePackages = "com.example.public")
			public class MyApplication { }
		Internal APIs in com.example.internal will not be scanned ‚Üí not exposed.
	2) Use @Profile to Disable in Certain Environments
		You can annotate internal endpoints with a Spring profile (e.g., internal) and enable them only in certain environments.
		
		@RestController
		@Profile("internal")
		@RequestMapping("/internal/products")
		public class InternalProductController {
			// Internal logic
		}
		
		Start app in prod without internal profile ‚Üí endpoints are hidden.
	3) Restrict Access Using Spring Security --> Role Based Security
		@Configuration
		@EnableWebSecurity
		public class SecurityConfig extends WebSecurityConfigurerAdapter {

			@Override
			protected void configure(HttpSecurity http) throws Exception {
				http
					.authorizeRequests()
						.antMatchers("/internal/**").hasRole("ADMIN") // restrict internal endpoints
						.antMatchers("/api/**").permitAll()          // public endpoints
					.and()
						.httpBasic(); // or JWT
			}
		}
	4) Conditional Endpoint Registration
		@RestController
		@RequestMapping("/internal/products")
		@ConditionalOnProperty(name = "internal.api.enabled", havingValue = "true", matchIfMissing = false)
		public class InternalProductController { ... }
	5) Hide Endpoints from Swagger / OpenAPI
		You might want to keep internal endpoints in the application but hide them from documentation:
			@Operation(hidden = true)
			@GetMapping("/internal/products")
			public List<Product> getInternalProducts() { ... }



How will you consume restful API ?








Questions on Spring Boot part- 5

How will you handle exceptions in your project ?
1) Why Exception Handling?
	To provide consistent, meaningful error responses to clients.
	To prevent stack traces from leaking to the client.
	To map different exceptions to proper HTTP status codes.
2) Approaches to Handle Exceptions in Spring Boot
	a) Try-Catch in Controller (Not Recommended)
		Simple but not scalable or maintainable.
		@GetMapping("/products/{id}")
		public ResponseEntity<Product> getProduct(@PathVariable Long id) {
			try {
				Product product = productService.getById(id);
				return ResponseEntity.ok(product);
			} catch (ProductNotFoundException ex) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
			}
		}
	b) @ExceptionHandler in Controller: Handles exceptions only for that controller.
		@RestController
		@RequestMapping("/api/products")
		public class ProductController {

			@GetMapping("/{id}")
			public Product getProduct(@PathVariable Long id) {
				return productService.getById(id);
			}

			@ExceptionHandler(ProductNotFoundException.class)
			public ResponseEntity<String> handleNotFound(ProductNotFoundException ex) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
			}
		}
	c) @ControllerAdvice (Global Exception Handling): Recommended approach for centralized exception handling.
		@ControllerAdvice
		public class GlobalExceptionHandler {
			@ExceptionHandler(ProductNotFoundException.class)
			public ResponseEntity<ErrorResponse> handleNotFound(ProductNotFoundException ex) {
				ErrorResponse error = new ErrorResponse(
					HttpStatus.NOT_FOUND.value(),
					ex.getMessage()
				);
				return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
			}
			@ExceptionHandler(Exception.class)
			public ResponseEntity<ErrorResponse> handleGeneric(Exception ex) {
				ErrorResponse error = new ErrorResponse(
					HttpStatus.INTERNAL_SERVER_ERROR.value(),
					"Something went wrong"
				);
				return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
			}
		}
	d) Using @ResponseStatus on Exceptions: Annotate custom exceptions to automatically return an HTTP status.
		@ResponseStatus(HttpStatus.NOT_FOUND)
		public class ProductNotFoundException extends RuntimeException {
			public ProductNotFoundException(String message) {
				super(message);
			}
		}
	e) Validation Exceptions: or @Valid or @Validated inputs, handle field errors:
		@ExceptionHandler(MethodArgumentNotValidException.class)
		public ResponseEntity<Map<String, String>> handleValidation(MethodArgumentNotValidException ex) {
			Map<String, String> errors = new HashMap<>();
			ex.getBindingResult().getFieldErrors()
			  .forEach(error -> errors.put(error.getField(), error.getDefaultMessage()));
			return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
		}
	

How can you avoid defining handlers for multiple exceptions, or what is the best practice for handling exceptions ?


How will you validate or sanitise your input payload ?
	Sanitization ensures input doesn‚Äôt contain malicious content like XSS, SQL Injection, etc.
	
	a) Escape HTML / Special Characters
		import org.apache.commons.text.StringEscapeUtils;
		
		String sanitized = StringEscapeUtils.escapeHtml4(userInput);
		
		1) If your Spring Boot API stores the raw input without sanitization, it‚Äôs storing the malicious script.
		2) When AngularJS renders this input as HTML without escaping, the script executes.
		3) So backend sanitization is recommended even if frontend uses AngularJS auto-escaping.
		4) Save safeInput in DB ‚Üí prevents XSS even if frontend rendering fails.


	b) Validate Allowed Patterns: Use regex validation for emails, phone numbers, or custom formats:
		@Pattern(regexp = "^[a-zA-Z0-9 ]+$", message = "Invalid characters in name")
		private String name;
	c) Use Parameterized Queries / ORM
			Prevent SQL Injection when storing input in database.
			Avoid string concatenation in SQL; always use JPA or PreparedStatement.




How can you define custom bean validation ?

Yes! In Spring Boot, you can define custom bean validation when the built-in annotations (@NotNull, @Size, @Pattern, etc.) are not enough. This involves creating a custom annotation and implementing a validator. Let me explain step by step with an example.

1Ô∏è) Create a Custom Annotation
	import jakarta.validation.Constraint;
	import jakarta.validation.Payload;
	import java.lang.annotation.*;
	@Documented
	@Constraint(validatedBy = ProductTypeValidator.class)  // link to validator
	@Target({ ElementType.FIELD })
	@Retention(RetentionPolicy.RUNTIME)
	public @interface ValidProductType {
		String message() default "Invalid product type";  // default error message
		Class<?>[] groups() default {};
		Class<? extends Payload>[] payload() default {};
	}
2Ô∏è)Implement the Validator
	Create a class that implements ConstraintValidator<Annotation, FieldType>.
	import jakarta.validation.ConstraintValidator;
	import jakarta.validation.ConstraintValidatorContext;
	import java.util.Arrays;
	import java.util.List;

	public class ProductTypeValidator implements ConstraintValidator<ValidProductType, String> {
		private final List<String> allowedTypes = Arrays.asList("Electronics", "Clothing", "Books");

		@Override
		public boolean isValid(String value, ConstraintValidatorContext context) {
			if (value == null) return false;  // null check
			return allowedTypes.contains(value);
		}
	}

3Ô∏è) Use the Custom Annotation in DTO
	public class ProductDTO {
		@NotNull(message = "Product name cannot be null")
		private String name;
		@ValidProductType
		private String productType;
	}
4) Optional: Custom Error Messages with Parameters --> You can make your annotation dynamic, e.g., accept a list of allowed values:
	@Target({ ElementType.FIELD })
	@Retention(RetentionPolicy.RUNTIME)
	@Constraint(validatedBy = ProductTypeValidator.class)
	public @interface ValidProductType {
		String message() default "Invalid product type. Allowed types: {types}";
		Class<?>[] groups() default {};
		Class<? extends Payload>[] payload() default {};
		String[] types() default {}; // pass allowed types
	}
	
	import jakarta.validation.ConstraintValidator;
	import jakarta.validation.ConstraintValidatorContext;
	import java.util.Arrays;
	import java.util.List;

	public class ProductTypeValidator implements ConstraintValidator<ValidProductType, String> {
		private List<String> allowedTypes;
		private String messageTemplate;
		@Override
		public void initialize(ValidProductType constraintAnnotation) {
			this.allowedTypes = Arrays.asList(constraintAnnotation.types());
			this.messageTemplate = constraintAnnotation.message();
		}
		@Override
		public boolean isValid(String value, ConstraintValidatorContext context) {
			if (value == null) return false;
			if (!allowedTypes.contains(value)) {
				// Customize the message dynamically
				context.disableDefaultConstraintViolation();
				context.buildConstraintViolationWithTemplate(
						messageTemplate.replace("{types}", String.join(", ", allowedTypes))
				).addConstraintViolation();
				return false;
			}
			return true;
		}
	}

	Example:
	===============================
	public class ProductDTO {
		private String name;
		@ValidProductType(types = {"Electronics", "Clothing", "Books"})
		private String productType;
		private double price;
	}

	

use case : let‚Äôs say you find a bug in production environment and now you want to debug that scenario ,How can you do that from your local ?
	1) Identify failing API & payload from prod logs.
	2) Copy a subset of production DB locally.
	3) Run Spring Boot locally with the same profile.
	4) Attach debugger and set breakpoints around the failing logic.
	5) Replay the API call with Postman or test scripts.
	6) Inspect variables, service calls, and logs to find the root cause.

How can you enable a specific environment without using profiles? OR what is the alternative to profiles to achieving same use case ?
1) Using Externalized Configuration (Property / YAML Files)
Option A: Specify Config File at Runtime
	java -jar myapp.jar --spring.config.location=file:/path/to/config/application-prod.yml
Option B: Specify Config File via Environment Variable
	export SPRING_CONFIG_LOCATION=/path/to/config/application-prod.yml
	java -jar myapp.jar
2) Use Command Line Arguments
java -jar myapp.jar \
    --spring.datasource.url=jdbc:oracle:thin:@prod-db:1521:ORCL \
    --spring.datasource.username=produser \
    --spring.datasource.password=prodpass
3) Use Environment Variables: Spring Boot reads OS environment variables automatically.
	export SPRING_DATASOURCE_URL=jdbc:oracle:thin:@prod-db:1521:ORCL
	export SPRING_DATASOURCE_USERNAME=produser
	export SPRING_DATASOURCE_PASSWORD=prodpass
	java -jar myapp.jar
4) Conditional Beans with Custom Properties: Instead of using @Profile("dev"), you can use a custom property:
	# application.yml
	app.env=prod
	@Configuration
	public class DataSourceConfig {
		@Value("${app.env}")
		private String env;
		@Bean
		public DataSource dataSource() {
			if ("prod".equals(env)) {
				return createProdDataSource();
			} else {
				return createDevDataSource();
			}
		}
	}
5) Use Spring Environment Programmatically
	@Autowired
	private Environment environment;
	public void checkEnv() {
		String env = environment.getProperty("app.env");
		if ("prod".equals(env)) {
			// configure production-specific logic
		}
	}
6) Use @Conditional or Custom Condition Classes: Spring Boot supports @Conditional to load beans based on a condition.
	@Bean
	@Conditional(ProdCondition.class)
	public DataSource prodDataSource() {
		return createProdDataSource();
	}


	



What is the difference between @Profile & @ConditioOnXXX ?
	@Profile is used to load beans based on the active Spring profile, such as dev or prod. For example, beans annotated with @Profile("prod") are only loaded if the prod profile is active. On the other hand, @Conditional and its variations like @ConditionalOnProperty provide more flexible, fine-grained control. They allow beans to be loaded based on properties, classpath availability, missing beans, or custom conditions, making them suitable for runtime-based configuration rather than predefined profiles.


What is AOP ?
	AOP (Aspect-Oriented Programming) is a programming paradigm that allows you to separate cross-cutting concerns from your business logic. It‚Äôs widely used in Spring to handle concerns that affect multiple parts of an application, like logging, security, transactions, or caching, without cluttering the core business code.
	
	| Term              | Meaning                                                                                                                |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------- |
| **Aspect**        | A module that encapsulates a cross-cutting concern (e.g., logging, security).                                          |
| **Join Point**    | A point during the execution of a program (e.g., method execution, exception).                                         |
| **Advice**        | Action taken by an aspect at a join point. Types: `@Before`, `@After`, `@Around`, `@AfterReturning`, `@AfterThrowing`. |
| **Pointcut**      | Expression that matches one or more join points. Defines **where** advice should be applied.                           |
| **Weaving**       | Process of linking aspects with target objects. Can happen at compile-time, load-time, or runtime.                     |
| **Target Object** | The object being advised by an aspect.                                                                                 |


What is pointcut & join Points in AOP ?
	A Join Point is a specific point in the execution of a program where an aspect can be applied.
	In Spring AOP, a join point is always a method execution (Spring AOP is proxy-based, so it only intercepts method calls).

		| Join Point Type          | Example                                    |
		| ------------------------ | ------------------------------------------ |
		| Method execution         | Calling `productService.getProduct("101")` |
		| Exception thrown         | When a method throws `RuntimeException`    |
		| Method returning a value | After `getProduct` returns "Product-101"   |


What are different type of advice ?


use case ‚Äî can I use AOP to evaluate performance of a method or is this possible to design a logging framework to capture request and response body of a method ?
	Yes, AOP is perfect for evaluating performance or logging request/response bodies because these are cross-cutting concerns. Using @Around advice, I can intercept method calls to measure execution time or capture inputs and outputs without changing the business code. This approach makes the monitoring and logging framework centralized, reusable, and maintainable.





Questions on Spring Boot part- 6
How does your application interact with the database and which frameworks are you using?
	Spring Data JPA + Hibernate ‚Üí ORM, simplifies CRUD, relationships, and query abstraction
	Spring Data Redis (Jedis client) ‚Üí caching, fast key-value lookups
	HikariCP ‚Üí database connection pooling (default in Spring Boot)

JdbcTemplate (optional use case) ‚Üí direct SQL execution, batch updates, performance tuning
Why is it important to configure a physical naming strategy?
	Configuring a physical naming strategy is important because it ensures consistency between our Java entity field names and the actual database schema. For example, Java typically uses camelCase while databases often use snake_case. Without it, Hibernate might generate table/column names that don‚Äôt exist, leading to runtime errors. By using SpringPhysicalNamingStrategy, we automatically map productName to product_name and ProductCategory to product_category, avoiding mismatches and reducing boilerplate annotations
	
	
What are the key benefits of using Spring Data JPA ?
| Benefit                              | Explanation                                                                                                         | Example                                                                                     |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| **1. Simplified Data Access**        | Eliminates boilerplate DAO code. You just define repository interfaces, and Spring generates implementations.       | `interface ProductRepository extends JpaRepository<Product, Long>` gives you CRUD for free. |
| **2. Powerful Query Abstraction**    | Supports derived query methods, JPQL, native SQL, and `@Query` annotation.                                          | `findByProductName(String name)` auto-generates query.                                      |
| **3. Transaction Management**        | Works seamlessly with Spring‚Äôs `@Transactional`, handling commit/rollback automatically.                            | Annotate service methods with `@Transactional`.                                             |
| **4. Consistency Across Databases**  | Hibernate (default JPA provider) abstracts DB differences, so code is portable across Oracle, MySQL, Postgres, etc. | Same repository works across different RDBMS.                                               |
| **5. Paging and Sorting Built-In**   | Provides `Pageable` and `Sort` APIs for efficient data retrieval.                                                   | `findAll(PageRequest.of(0, 10, Sort.by("price")))`                                          |
| **6. Integration with Spring Boot**  | Auto-configures datasource, connection pool (HikariCP), transaction manager, and repositories.                      | Just add `spring-boot-starter-data-jpa`.                                                    |
| **7. Auditing Support**              | Tracks creation & update timestamps and user details with annotations.                                              | `@CreatedDate`, `@LastModifiedDate`.                                                        |
| **8. Entity Relationships Handling** | Simplifies working with associations like `@OneToMany`, `@ManyToOne`, `@ManyToMany`.                                | Automatically manages joins and cascades.                                                   |
| **9. Caching Support**               | Works with first-level (Session) and second-level caches (EhCache, Redis, etc.) for performance.                    | Frequently queried entities served from cache.                                              |
| **10. Reduces Human Errors**         | Centralized repository pattern ‚Üí fewer raw SQL queries ‚Üí less prone to typos or mismatches.                         | Avoids hand-written SQL for basic CRUD.                                                     |





What are the differences between Hibernate, JPA, and Spring Data JPA?


How can you connect multiple databases or data sources in a single application?
	Multi-Tenancy in Spring Boot (Using AbstractRoutingDataSource)
	
	public class TenantContext {
		private static final ThreadLocal<String> currentTenant = new ThreadLocal<>();
		public static void setTenantId(String tenantId) {
			currentTenant.set(tenantId);
		}
		public static String getTenantId() {
			return currentTenant.get();
		}
		public static void clear() {
			currentTenant.remove();
		}
	}
	public class TenantRoutingDataSource extends AbstractRoutingDataSource {
		@Override
		protected Object determineCurrentLookupKey() {
			// Pick tenantId from context (set per request)
			return TenantContext.getTenantId();
		}
	}
	@Configuration
	public class DataSourceConfig {
		@Bean
		public DataSource tenantDataSource() {
			TenantRoutingDataSource routingDataSource = new TenantRoutingDataSource();
			Map<Object, Object> dataSources = new HashMap<>();
			DataSource tenant1 = DataSourceBuilder.create()
					.url("jdbc:mysql://localhost:3306/tenant1db")
					.username("user1")
					.password("pass1")
					.build();
			DataSource tenant2 = DataSourceBuilder.create()
					.url("jdbc:mysql://localhost:3306/tenant2db")
					.username("user2")
					.password("pass2")
					.build();
			dataSources.put("TENANT_1", tenant1);
			dataSources.put("TENANT_2", tenant2);
			routingDataSource.setTargetDataSources(dataSources);
			routingDataSource.setDefaultTargetDataSource(tenant1);
			return routingDataSource;
		}
	}
	@Component
	public class TenantInterceptor implements HandlerInterceptor {
		@Override
		public boolean preHandle(HttpServletRequest request,
								 HttpServletResponse response,
								 Object handler) {
			String tenantId = request.getHeader("X-Tenant-ID");
			if (tenantId == null) {
				tenantId = "TENANT_1"; // default
			}
			TenantContext.setTenantId(tenantId);
			return true;
		}
		@Override
		public void afterCompletion(HttpServletRequest request,
									HttpServletResponse response,
									Object handler,
									Exception ex) {
			TenantContext.clear();
		}
	}



What are the different ways to define custom queries in Spring Data JPA ?

1. Derived Query Methods	
	Spring parses method names and generates SQL automatically	
	java List<Product> findByProductType(String type);	
	
	Simple queries that follow naming conventions
2. @Query Annotation (JPQL)	
	Write JPQL queries directly inside repository methods	
	java @Query("SELECT p FROM Product p WHERE p.productType = :type") 
	List<Product> findByType(@Param("type") String type);	
	
	More control, joins, aggregations
3. @Query with Native SQL	
	Use raw SQL instead of JPQL	 
	@Query(value = "SELECT * FROM products WHERE product_type = :type", nativeQuery = true) 
	List<Product> findByTypeNative(@Param("type") String type);	
	
	When JPQL can‚Äôt handle vendor-specific SQL
4. Named Queries	
	Predefine JPQL queries inside entity classes (@NamedQuery)	
	
	@Entity 
	@NamedQuery(name="Product.findByType", query="SELECT p FROM Product p WHERE p.productType = :type") 
	class Product {} 
	Then use: List<Product> findByType(@Param("type") String type);	
	
	Queries reused across multiple repositories
5. Named Native Queries	
	Predefine raw SQL in entity class (@NamedNativeQuery)	
	@NamedNativeQuery(name="Product.findByTypeNative", query="SELECT * FROM products WHERE product_type = ?", resultClass=Product.class)	
	
	For complex vendor-specific SQL
6. Specifications (Criteria API)	
	Build dynamic queries programmatically	
	public class ProductSpecs { 
		public static Specification<Product> hasType(String type) { 
			return (root, query, cb) -> cb.equal(root.get("productType"), type); 
		} 
	} 
	
	Usage: repo.findAll(ProductSpecs.hasType("Electronics"));	
	Dynamic filtering, search screens
7. Query by Example (QBE)	
	Create probe objects to query	
	Product probe = new Product(); 
	probe.setProductType("Electronics"); 
	Example<Product> example = Example.of(probe); 
	List<Product> result = repo.findAll(example);	
	
	When queries depend on user input fields
8. Custom Repository Implementation	
	Write your own DAO logic beyond Spring Data‚Äôs auto-gen	
	public interface ProductRepositoryCustom { 
		List<Product> findProductsCustomLogic(); 
	} 
	
	@Repository 
	public class ProductRepositoryImpl implements ProductRepositoryCustom { 
		@PersistenceContext 
		private EntityManager em; 
		public List<Product> findProductsCustomLogic() { 
			return em.createQuery("SELECT p FROM Product p").getResultList(); 
		} 
	}



Can you provide example to find results based on some range
Ex 1 : Find list of employees whose age in between 30 lakh to 35 lakh
Ex 2 : find avg salary of employees in an organization

public interface EmployeeRepository extends JpaRepository<Employee, Long> {

    // Derived query by method naming
    List<Employee> findBySalaryBetween(Double minSalary, Double maxSalary);
}


@Query("SELECT e FROM Employee e WHERE e.salary BETWEEN :min AND :max")
List<Employee> findEmployeesInSalaryRange(@Param("min") Double min, @Param("max") Double max);


@Query(value = "SELECT * FROM employees WHERE salary BETWEEN :min AND :max", nativeQuery = true)
List<Employee> findEmployeesInSalaryRangeNative(@Param("min") Double min, @Param("max") Double max);


@Query("SELECT AVG(e.salary) FROM Employee e")
Double findAverageSalary();

@Query(value = "SELECT AVG(salary) FROM employees", nativeQuery = true)
Double findAverageSalaryNative();




8. How will you define entity relationships or association mapping in Spring Data JPA?
(Use Case: Consider an e-commerce application where each customer can have multiple orders. Here, a Customer entity can be associated with multiple Order entities.)
In Spring Data JPA, we define entity relationships (association mapping) using annotations like @OneToOne, @OneToMany, @ManyToOne, @ManyToMany.


9. Is this possible to execute Join query in Spring Data JPA ? If yes, how can you add some insights ?
1. JPQL (Entity-based Join)
	@Query("SELECT c FROM Customer c JOIN c.orders o WHERE o.price > :price")
List<Customer> findCustomersWithOrdersAbove(@Param("price") Double price);

2. JPQL with Fetch Join (Solve N+1 Problem)
	@Query("SELECT c FROM Customer c JOIN FETCH c.orders WHERE c.id = :customerId")
Customer findCustomerWithOrders(@Param("customerId") Long customerId);

3. Native SQL JOIN
	@Query(value = "SELECT c.* FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.price > :price",
       nativeQuery = true)
List<Customer> findCustomersWithOrdersNative(@Param("price") Double price);

4. Projection with JOIN
		public interface CustomerOrderView {
			String getCustomerName();
			String getProductName();
		}

		@Query("SELECT c.name AS customerName, o.productName AS productName " +
			   "FROM Customer c JOIN c.orders o")
		List<CustomerOrderView> fetchCustomerOrderDetails();

5. Criteria API (Dynamic Joins)
	public List<Customer> findCustomersWithOrdersCriteria(Double price) {
		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<Customer> query = cb.createQuery(Customer.class);
		Root<Customer> customer = query.from(Customer.class);
		Join<Customer, Order> orders = customer.join("orders");
		query.select(customer).where(cb.greaterThan(orders.get("price"), price));
		return em.createQuery(query).getResultList();
	}



10. How will you implement pagination & Sorting in Spring Data JPA ?

public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    Page<Employee> findBySalaryGreaterThan(Double salary, Pageable pageable);
}

@GetMapping("/employees")
public Page<Employee> getEmployees(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "5") int size) {

    Pageable pageable = PageRequest.of(page, size);
    return employeeRepository.findAll(pageable);
}

//Paginration + Sorting
@GetMapping("/employees/paged-sorted")
public Page<Employee> getEmployeesPagedAndSorted(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "5") int size,
        @RequestParam(defaultValue = "name") String sortBy) {

    Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));
    return employeeRepository.findAll(pageable);
}











Questions on Spring Boot part- 7


How will you handle auditing in your application ?
Explain Different annotation used for auditing
How can auditing be applied in a NoSQL database like MongoDB in Spring Boot?
How can we customize auditing in Spring Boot ?
How do you track entity modifications across different users in a microservices architecture, and how can a centralized audit service help with cross-service auditing?
What is transaction management and how it works ?
How will you handle transaction in your application ?
What are different type of Isolation and Propagation ?
Can we use transaction in private methods ?
How will you handle transaction in distributed microservice ?
Can we use transaction in multiple microservices why or why not ?
NOTE : This blog will continue with regular uploads of questions from various modules of Spring Boot. You will receive notifications if you follow the JavaTechie Medium

Spring Boot In-depth Interview Q&A
