<configuration>

    <!-- Optional: Register custom converter for masking -->
    <!--
    <conversionRule conversionWord="mask"
                    converterClass="com.example.demo.log.MaskingConverter" />
    -->

    <!-- ========================= -->
    <!-- Appender 1: INFO logs only -->
    <!-- ========================= -->
    <appender name="INFO_CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>

        <encoder class="ch.qos.logback.classic.encoder.LayoutWrappingEncoder">
            <layout class="com.util.JsonLockBackEvent">
                <pattern>[INFO] %d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
            </layout>
        </encoder>
    </appender>

    <!-- ========================= -->
    <!-- Appender 2: Masked logs -->
    <!-- DEBUG, WARN, ERROR, optional TRACE -->
    <!-- ========================= -->
    <appender name="MASKED_CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!-- Accept DEBUG and higher levels -->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>DEBUG</level>
        </filter>

        <!-- Deny INFO logs -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>DENY</onMatch>
            <onMismatch>NEUTRAL</onMismatch>
        </filter>

        <!-- Optional: Include TRACE logs -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>TRACE</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>NEUTRAL</onMismatch>
        </filter>

        <!-- Masking regex (if handled inside layout or converter) -->
        <encoder class="ch.qos.logback.classic.encoder.LayoutWrappingEncoder">
            <layout class="com.util.JsonLockBackEvent">
				<!-- JsonLockBackEvent extends ch.qos.logback.classic.PatternLayout-->
				<maskPattern> <![CDATA[(\d{4})\d{8}(\d{4})]]>  </maskPattern>
				
                <pattern>[%level] %d{yyyy-MM-dd HH:mm:ss} %-5logger{36} - %msg%n</pattern>
            </layout>
        </encoder>
    </appender>

    <!-- ========================= -->
    <!-- Root Logger -->
    <!-- ========================= -->
    <root level="DEBUG">
        <appender-ref ref="INFO_CONSOLE"/>
        <appender-ref ref="MASKED_CONSOLE"/>
    </root>

</configuration>









package com.util;

import ch.qos.logback.classic.PatternLayout;
import ch.qos.logback.classic.spi.ILoggingEvent;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JsonLockBackEvent extends PatternLayout {

    private static final ObjectMapper MAPPER = new ObjectMapper()
            .disable(SerializationFeature.INDENT_OUTPUT); // ensure compact JSON

    private List<Pattern> maskPatterns = new ArrayList<>();
    private String hostName;
    private String activeProfile;
    private String sdlc;

    public JsonLockBackEvent() {
        try {
            this.hostName = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            this.hostName = "unknown-host";
        }
        this.activeProfile = System.getProperty("spring.profiles.active", "default");
        this.sdlc = System.getProperty("sdlc.env", "dev");
    }

    public void setMaskPattern(String maskPattern) {
        if (maskPattern != null && !maskPattern.isEmpty()) {
            this.maskPatterns.add(Pattern.compile(maskPattern));
        }
    }

    @Override
    public String doLayout(ILoggingEvent event) {
        Map<String, Object> logMap = new LinkedHashMap<>();
        logMap.put("timestamp", new Date(event.getTimeStamp()).toString());
        logMap.put("level", event.getLevel().toString());
        logMap.put("thread", event.getThreadName());
        logMap.put("logger", event.getLoggerName());
        logMap.put("message", mask(event.getFormattedMessage()));
        logMap.put("mdc", event.getMDCPropertyMap());
        logMap.put("host", hostName);
        logMap.put("profile", activeProfile);
        logMap.put("sdlc", sdlc);

        logMap.put("userFields", Map.of(
                "requestId", event.getMDCPropertyMap().getOrDefault("requestId", "N/A"),
                "userId", event.getMDCPropertyMap().getOrDefault("userId", "anonymous")
        ));

        if (event.getThrowableProxy() != null) {
            logMap.put("exception", event.getThrowableProxy().getClassName());
            logMap.put("errorMessage", event.getThrowableProxy().getMessage());
			logMap.put("stackTrace", event.getThrowableProxy().getMessage());
        }

        try {
            // single-line JSON + newline at the end
            return MAPPER.writeValueAsString(logMap) + System.lineSeparator();
        } catch (Exception e) {
            return "{\"error\":\"Failed to serialize log\"}\n";
        }
    }

    private String mask(String message) {
        if (message == null) return null;
        String masked = message;
        for (Pattern p : maskPatterns) {
            Matcher m = p.matcher(masked);
            masked = m.replaceAll("****MASKED****");
        }
        return masked;
    }
}




import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.spi.LocationAwareLogger;

public class MaskingLogger {

    private static final String FQCN = MaskingLogger.class.getName();

    private final LocationAwareLogger logger;

    public MaskingLogger(Class<?> clazz) {
        Logger baseLogger = LoggerFactory.getLogger(clazz);
        if (baseLogger instanceof LocationAwareLogger) {
            this.logger = (LocationAwareLogger) baseLogger;
        } else {
            throw new IllegalStateException("Logger is not LocationAwareLogger");
        }
    }

    public void info(String msg) {
        logger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);
    }

    public void debug(String msg) {
        logger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);
    }

    public void mask(String msg) {
        String maskedMsg = maskSensitiveData(msg);
        // Use INFO level for example here, but you can choose any
        logger.log(null, FQCN, LocationAwareLogger.INFO_INT, maskedMsg, null, null);
    }

    private String maskSensitiveData(String msg) {
        // Your masking logic
        return msg.replaceAll("(\\d{4})\\d{8}(\\d{4})", "$1********$2");
    }
}




public class MyClass {
    private static final MaskingLogger log = new MaskingLogger(MyClass.class);

    public void test() {
        log.info("This is info");
        log.mask("Credit card: 1234567890123456");
    }
}



<configuration>
  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <root level="debug">
    <appender-ref ref="CONSOLE" />
  </root>
</configuration>




